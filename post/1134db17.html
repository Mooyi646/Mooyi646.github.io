<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281527777.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281527777.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281527777.png">
  <link rel="mask-icon" href="https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281527777.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mooyi646.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="Garbage Collection(GC)回收无任何对象引用的对象占据的内容空间，即不会再被使用的对象的内容空间。 引用：若Reference类型的数据中存储的数值代表另一块内容的起始地址，则称这块内存为一个引用 垃圾：无任何对象引用的对象 回收：清理垃圾占用的内存空间而非对象本身 发生地点：一般在堆内存中，因为大部分对象都储存在堆内存中 发生时间：程序空闲时不定时回收">
<meta property="og:type" content="article">
<meta property="og:title" content="GC">
<meta property="og:url" content="https://mooyi646.github.io/post/1134db17.html">
<meta property="og:site_name" content="Mooyi&#39;s Blog">
<meta property="og:description" content="Garbage Collection(GC)回收无任何对象引用的对象占据的内容空间，即不会再被使用的对象的内容空间。 引用：若Reference类型的数据中存储的数值代表另一块内容的起始地址，则称这块内存为一个引用 垃圾：无任何对象引用的对象 回收：清理垃圾占用的内存空间而非对象本身 发生地点：一般在堆内存中，因为大部分对象都储存在堆内存中 发生时间：程序空闲时不定时回收">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-12-13T11:10:58.000Z">
<meta property="article:modified_time" content="2023-12-13T11:18:16.208Z">
<meta property="article:author" content="Mooyi">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="GC垃圾回收">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://mooyi646.github.io/post/1134db17.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>GC | Mooyi's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mooyi's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://mooyi646.github.io/post/1134db17.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281528071.png">
      <meta itemprop="name" content="Mooyi">
      <meta itemprop="description" content="Live with fun">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mooyi's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          GC
        </h1>

        <div class="post-meta">

        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-12-13 19:10:58 / Modified: 19:18:16" itemprop="dateCreated datePublished" datetime="2023-12-13T19:10:58+08:00">2023-12-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learning/" itemprop="url" rel="index"><span itemprop="name">Learning</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learning/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/post/1134db17.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="post/1134db17.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>7.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>7 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Garbage-Collection-GC"><a href="#Garbage-Collection-GC" class="headerlink" title="Garbage Collection(GC)"></a>Garbage Collection(GC)</h1><p>回收无任何对象引用的对象占据的内容空间，即不会再被使用的对象的内容空间。</p>
<p>引用：若Reference类型的数据中存储的数值代表另一块内容的起始地址，则称这块内存为一个引用</p>
<p>垃圾：无任何对象引用的对象</p>
<p>回收：清理垃圾占用的内存空间而非对象本身</p>
<p>发生地点：一般在堆内存中，因为大部分对象都储存在堆内存中</p>
<p>发生时间：程序空闲时不定时回收</p>
<span id="more"></span>



<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><h3 id="强引用StrongReference"><a href="#强引用StrongReference" class="headerlink" title="强引用StrongReference"></a>强引用StrongReference</h3><p>默认即为强引用，任何一个对象的赋值操作就产生了对这个对象的强引用。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<p>特征：只要强引用存在，被引用的对象就永远不会被回收</p>
<h3 id="软引用SoftReference"><a href="#软引用SoftReference" class="headerlink" title="软引用SoftReference"></a>软引用SoftReference</h3><p>用于描述可能有用，但非必须的对象。</p>
<p>JDK1.2之后提供了<code>SoftReference</code>类来实现软引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoftReference</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Reference</span>&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SoftReference</span><span class="params">(T referent)</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">SoftReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; q)</span></span><br></pre></td></tr></table></figure>

<p>特征：只有在内存不足的情况下，被引用的对象才会被回收。</p>
<h3 id="弱引用WeakReference"><a href="#弱引用WeakReference" class="headerlink" title="弱引用WeakReference"></a>弱引用WeakReference</h3><p>构造函数类似于软应用</p>
<p>特征：只要垃圾回收执行，其引用的对象就会被回收。</p>
<h3 id="虚引用PhantomReference"><a href="#虚引用PhantomReference" class="headerlink" title="虚引用PhantomReference"></a>虚引用PhantomReference</h3><p>作用：跟踪垃圾回收器收集对象的活动。GC的过程中，如果发现有<code>PhantomReference</code>，GC则会将引用放到<code>ReferenceQueue</code>中，由程序员自己处理，当程序员调用<code>ReferenceQueue.pull()</code>方法，将引用出<code>ReferenceQueue</code>移除之后，Reference对象会变成<code>Inactive</code>状态，意味着被引用的对象可以被回收了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PhantomReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; q)</span></span><br></pre></td></tr></table></figure>



<h2 id="判断“垃圾”"><a href="#判断“垃圾”" class="headerlink" title="判断“垃圾”"></a>判断“垃圾”</h2><p>垃圾回收算法的一般过程：</p>
<ol>
<li>找到所有存活对象</li>
<li>回收被无用对象占用的内存空间，使其可被再次使用</li>
</ol>
<h3 id="引用计数法Reference-Counting-Collector"><a href="#引用计数法Reference-Counting-Collector" class="headerlink" title="引用计数法Reference Counting Collector"></a>引用计数法Reference Counting Collector</h3><p>思路：堆中每个对象都有一个引用计数器。</p>
<ol>
<li>对象被创建并初始化后，计数器设置为<code>1</code></li>
<li>每当有一个地方引用它，计数器值<code>加1</code></li>
<li>引用失效时（超过生命周期、设置为新值），计数器<code>减1</code></li>
<li>计数器为<code>0</code>的对象可被垃圾回收</li>
<li>当一个对象被垃圾收集时，它引用的任何对象计数<code>减1</code>。</li>
</ol>
<p>优点：</p>
<ul>
<li>执行简单，判定效率高，交织在程序运行中。</li>
<li>对程序不被长时间打断的实时环境比较有利（OC内存管理使用该算法）</li>
</ul>
<p>缺点：</p>
<ul>
<li>难以检测出对象之间的循环引用</li>
<li>增加了程序开销</li>
</ul>
<h3 id="根搜索算法Tracing-Collector"><a href="#根搜索算法Tracing-Collector" class="headerlink" title="根搜索算法Tracing Collector"></a>根搜索算法Tracing Collector</h3><p><strong>根集Root Set</strong></p>
<p>为正在执行的Java程序可以访问的<strong>引用变量</strong>（注：不是对象）集合，包括局部变量、参数、类变量。程序可以使用引用变量访问对象的属性和调用对象的方法。</p>
<p>GC Roots对象包括：</p>
<ul>
<li>虚拟机栈中引用的对象（栈帧中的本地变量表）；</li>
<li>方法区中的常量引用的对象；</li>
<li>方法区中的类静态属性引用的对象；</li>
<li>本地方法栈中JNI（Native方法）的引用对象。</li>
<li>活跃线程。</li>
</ul>
<p>思路：</p>
<ol>
<li>通过名为“GC Roots”的对象作为起始点，寻找对应的引用节点</li>
<li>从找到的引用节点开始继续向下寻找其引用节点[repeat]</li>
<li>搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，表明该对象不可用</li>
</ol>
<p>目前使用此方法判断对象是否存活。</p>
<p>标记可达对象：</p>
<p>【标记可达对象】</p>
<p>标记注意事项：</p>
<ul>
<li><p>开始标记前需暂停应用线程，若对象图一直处于变化状态则无法真正遍历。暂停线程以便JVM操作的情况称为安全点（Safe Point），会触发一次<code>Stop The World(STW)</code>暂停。垃圾回收是最常见的触发安全点的原因。</p>
</li>
<li><p>暂停的时间长短取决于存活对象的多少（非堆内对象与堆大小）</p>
</li>
<li><p>根搜索算法中，宣布对象死亡，至少要经历<strong>两次标记</strong>：</p>
<ol>
<li><p>对象在根搜索后发现没有与GC Roots相连接的引用链，则会被<strong>第一次标记</strong>并进行一个筛选。</p>
<p>筛选条件：该对象是否有必要执行<code>finalize()</code>，当对象未覆盖<code>finalize()</code>或该方法已被虚拟机调用过，虚拟机将其视为没有必要执行。</p>
</li>
<li><p>若该对象被判定为有必要执行<code>finalize()</code>，则该对象会被放置在<code>F-Queue</code>队列中，并在稍后由一条由虚拟机自动创建的、低优先级的<code>Finalizer</code>线程执行<code>finalize()</code></p>
<p>稍后GC将对<code>F-Queue</code>中的对象进行<strong>第二次小规模的标记</strong>。</p>
<p>若想在<code>finalize()</code>方法中拯救自己，则需在该方法中让该对象重新引用链上的任一对象建立关联即可（最后一次机会，一个对象的<code>finalize()</code>最多被系统调用一次）</p>
<p>还未被关联到任何链的对象会被回收</p>
</li>
</ol>
</li>
<li><p>GC判断对象是否可达看的是强引用</p>
</li>
</ul>
<h2 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h2><h3 id="标记-清除算法Mark-Sweep"><a href="#标记-清除算法Mark-Sweep" class="headerlink" title="标记-清除算法Mark-Sweep"></a>标记-清除算法Mark-Sweep</h3><p>使用了根集的概念，分为“标记”和“清除”两个阶段：首先标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实就是根搜索算法中判定垃圾对象的标记过程。</p>
<p>优点：无需进行对象的移动，仅对不存活的对象进行处理，在存活对象较多情况下高效</p>
<p>缺点：</p>
<ul>
<li><p>标记与清除过程的效率都不高：需使用空闲表记录所有空闲区域及其大小</p>
</li>
<li><p>标记清除后会产生大量不连续的内存碎片</p>
</li>
</ul>
<h3 id="标记-整理算法Mark-Compact"><a href="#标记-整理算法Mark-Compact" class="headerlink" title="标记-整理算法Mark-Compact"></a>标记-整理算法Mark-Compact</h3><p>标记过程与标记-清除算法一致。</p>
<p>在对垃圾对象的处理中，不是直接清理，而是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>优点：</p>
<ul>
<li>整理后，新对象分配只需通过指针碰撞便可完成，非常简单</li>
<li>空闲区域位置可知，无碎片问题</li>
</ul>
<p>缺点：</p>
<p>GC暂停时间增长，因为需要将所有对象拷贝到新的地方，还得更新其引用地址</p>
<p><code>mark-sweep</code>与<code>mark-compact</code>图示：</p>
<p>【标记清除&#x2F;标记整理图示】</p>
<h3 id="复制算法Copying"><a href="#复制算法Copying" class="headerlink" title="复制算法Copying"></a>复制算法Copying</h3><p>将内存按容量分为大小相等的两块，每次只是用其中一块（对象面），当这块内存用完，将还存活的对象复制到另一块内存上（空闲面），然后将已使用过的内存空间一次性清理。</p>
<p>【复制算法】</p>
<p>适用于：新生代（短生存期的对象），在老年代，即长生存期的对象中，其对象存活率较高，会执行较多的复制操作，效率会降低。所以老年代一般选用其他算法，如标记-整理算法</p>
<p>一种典型的基于Coping算法的垃圾回收是<code>stop-and-copy</code>算法，它将堆分成对象区和空闲区，在对象区与空闲区的切换过程中，程序暂停执行</p>
<p>优点：</p>
<ul>
<li>标记和复制阶段可同时进行</li>
<li>每次只对一块内存回收，高效</li>
<li>只需移动栈顶指针，按序分配内存即可，实现简单</li>
<li>无需考虑内存碎片出现</li>
</ul>
<p>缺点：需一块能容纳下所有存活对象的额外的内存空间，因此，可一次性分配的最大内存缩小了一半</p>
<h3 id="Adaptive算法"><a href="#Adaptive算法" class="headerlink" title="Adaptive算法"></a>Adaptive算法</h3><p>在特定的情况下，一些垃圾收集算法会优于其它算法。基于Adaptive算法的垃圾收集器就是监控当前堆的使用情况，并将选择适当算法的垃圾收集器。</p>
<h2 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h2><p>基于Generation算法，划分为：</p>
<ul>
<li>新生代Young<ul>
<li>Eden</li>
<li>Survivor<ul>
<li>FromSpace(Survivor0)</li>
<li>ToSpace(Survivor1)</li>
</ul>
</li>
</ul>
</li>
<li>老年代Old</li>
<li>持久代Permanent</li>
</ul>
<p>【hotspot heap structure】</p>
<p>所有<code>new</code>创建的对象内存都在堆中分配，其大小可以通过<code>Xmx</code>和<code>-Xms</code>来控制</p>
<h3 id="堆内存分配区域"><a href="#堆内存分配区域" class="headerlink" title="堆内存分配区域"></a>堆内存分配区域</h3><h4 id="新生代Young-Generation"><a href="#新生代Young-Generation" class="headerlink" title="新生代Young Generation"></a>新生代Young Generation</h4><p>几乎所有新生成的对象都放于此。</p>
<p>新生代按$8:1:1$分为<code>Eden</code>,<code>S0</code>,<code>S1</code>。大部分对象都在<code>Eden</code>区生成。</p>
<p>新对象生成时：</p>
<ol>
<li>Eden Space申请失败（因空间不足等），则会发起一次GC(<code>Minor GC/Scavenge GC</code>)</li>
<li>回收时先将<code>Eden</code>区存活对象复制到<code>S0</code>区，然后清空<code>Eden</code>区</li>
<li><code>S0</code>也满了时，将<code>Eden</code>区和<code>S0</code>区存活对象复制到<code>S1</code>，然后清空<code>Eden</code>和<code>S0</code></li>
<li>此时<code>S0</code>为空，然后将<code>S0</code>和<code>S1</code>交换，即保持<code>S1</code>为空</li>
<li>若<code>S1</code>不足以存放<code>Eden</code>和<code>S0</code>区存活对象时，将存活对象直接放入老年代</li>
</ol>
<blockquote>
<p><strong>Minor GC &#x2F;  Scavenge GC</strong></p>
<p>发生在新生代的GC。</p>
<p>非常频繁，不一定等Eden区满才发生，一般回收速度也较快。</p>
<p>新生代GC一般会有大量对象死去，只有少量存活，因此可以选择<strong>复制算法</strong>完成收集。</p>
</blockquote>
<p>对象在<code>Survivor</code>区躲过一次GC，则其年龄<code>加1</code>，默认年龄达到<code>15</code>时移动到老年代。</p>
<p>若是老年代也满了就会触发一次<code>Full GC</code>，也就是新生代、老年代都进行回收。新生代大小可以由<code>-Xmn</code>来控制，也可以用<code>-XX:SurvivorRatio</code>来控制Eden和Survivor的比例。</p>
<h4 id="老年代Old-Generation"><a href="#老年代Old-Generation" class="headerlink" title="老年代Old Generation"></a>老年代Old Generation</h4><p> 在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p>
<p>老年代内存大约为新生代的2倍。其内存满时会触发<code>Major GC/Full GC</code></p>
<p>一般大对象会被直接分配到老年代，大对象即为需要大量连续存储空间的对象，如大数组</p>
<blockquote>
<p><strong>Major GC &#x2F; Full GC</strong></p>
<p>发生在老年代的GC。经常伴随至少一次Minor GC</p>
<p>老年代对象声明周期长，所以Full GC不频繁，一般等老年代区满了才进行，速度比Minor GC慢10倍以上</p>
<p>若分配了Direct Memory，在老年代Full GC时，会清理掉Direct Memory中的废弃对象。</p>
<p>无额外空间进行分配担保，对象存活率高，必须使用<strong>标记-清除</strong>或<strong>标记-整理</strong>算法进行回收。</p>
<p>导致Full GC的原因可能有：</p>
<ul>
<li>老年代满</li>
<li>持久代满</li>
<li>System.gc()被调用</li>
<li>上一次GC后堆的各域分配策略动态变化</li>
</ul>
</blockquote>
<h4 id="持久代Persistence-Generation"><a href="#持久代Persistence-Generation" class="headerlink" title="持久代Persistence Generation"></a>持久代Persistence Generation</h4><p>用于存放静态文件（class, method）和常量</p>
<p>回收主要由两部分内容：废弃常量和无用类</p>
<p>永久代空间在Java SE8特性中已经被移除。取而代之的是元空间（<code>MetaSpace</code>）。因此不会再出现<code>java.lang.OutOfMemoryError: PermGen error</code>错误。</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>按执行机制分为四种垃圾回收器：</p>
<p>【四种垃圾回收器】</p>
<ul>
<li>串行垃圾回收器（Serial Garbage Collector）</li>
<li>并行垃圾回收器（Parallel Garbage Collector）</li>
<li>并发标记扫描垃圾回收器（CMS Garbage Collector）</li>
<li>G1垃圾回收器（G1 Garbage Collector）</li>
</ul>
<h3 id="串行垃圾回收器Serial"><a href="#串行垃圾回收器Serial" class="headerlink" title="串行垃圾回收器Serial"></a>串行垃圾回收器Serial</h3><p>通过持有应用程序所有的线程进行工作。为单线程环境设计，只是用一个单独的线程进行垃圾回收，通过冻结所有应用程序线程（STW）进行工作。</p>
<p>简单高效，适合简单的命令行程序，是client级别默认的GC方式。</p>
<p>通过JVM参数<code>-XX:+UseSerialGC</code>可以使用串行垃圾回收器。</p>
<h3 id="并行垃圾回收器Parallel"><a href="#并行垃圾回收器Parallel" class="headerlink" title="并行垃圾回收器Parallel"></a>并行垃圾回收器Parallel</h3><p>也叫throughput collector。是JVM的默认垃圾回收器。</p>
<p>使用多线程进行垃圾回收，与串行类似，执行垃圾回收的时候也会冻结所有的应用程序线程。</p>
<p>适合多CPU、对暂停时间要求较短的应用，是server级别默认采用的GC方式。</p>
<p>可用<code>-XX:+UseParallelGC</code>来强制指定，用<code>-XX:ParallelGCThreads=4</code>来指定线程数。</p>
<h3 id="并发标记扫描垃圾回收器CMS"><a href="#并发标记扫描垃圾回收器CMS" class="headerlink" title="并发标记扫描垃圾回收器CMS"></a>并发标记扫描垃圾回收器CMS</h3><p>使用多线程扫描堆内存，标记需清理的实例并清理被标记过的实例。</p>
<p>只有在以下两种情况下才持有应用程序所有线程：</p>
<ul>
<li>标记的引用对象在<code>Tenured</code>区域。</li>
<li>进行垃圾回收的时候，堆内存的数据被并发地改变。</li>
</ul>
<p>相较于并行垃圾回收器，CMS使用更多的CPU来确保程序的吞吐量。</p>
<p>若能分配更多的CPU以获得更好的性能，那么CMS是优于Parallel的首选。</p>
<p>通过JVM参数<code>-XX:+USeParNewGC</code>打开并发标记扫描垃圾回收器。</p>
<p>[更详细可见Hotspot部分](###6. CMS（标记—清除算法）)</p>
<h3 id="G1垃圾回收器Garbage-First"><a href="#G1垃圾回收器Garbage-First" class="headerlink" title="G1垃圾回收器Garbage First"></a>G1垃圾回收器Garbage First</h3><p>用于大堆内存区域。将堆内存分隔为多个区域，并在这些区域并行进行收集。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7010034105165299725">G1</a></p>
<h2 id="JVM配置参数"><a href="#JVM配置参数" class="headerlink" title="JVM配置参数"></a>JVM配置参数</h2><p>运行的垃圾回收器类型：</p>
<table>
<thead>
<tr>
<th align="left">Option</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-XX:+UseSerialGC</td>
<td align="left">Serial Garbage Collector</td>
</tr>
<tr>
<td align="left">-XX:+UseParallelGC</td>
<td align="left">Parallel Garbage Collector</td>
</tr>
<tr>
<td align="left">-XX:+UseConcMarkSweepGC</td>
<td align="left">CMS Garbage Collector</td>
</tr>
<tr>
<td align="left">-XX:ParallelCMSThreads&#x3D;</td>
<td align="left">CMS Collector – number of threads to use</td>
</tr>
<tr>
<td align="left">-XX:+UseG1GC</td>
<td align="left">G1 Gargbage Collector</td>
</tr>
</tbody></table>
<p>优化选项：</p>
<table>
<thead>
<tr>
<th align="left">Option</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-Xms</td>
<td align="left">初始化堆内存大小</td>
</tr>
<tr>
<td align="left">-Xmx</td>
<td align="left">堆内存最大值</td>
</tr>
<tr>
<td align="left">-Xmn</td>
<td align="left">新生代大小</td>
</tr>
<tr>
<td align="left">-XX:PermSize</td>
<td align="left">持久代大小</td>
</tr>
<tr>
<td align="left">-XX:MaxPermSize</td>
<td align="left">持久代最大容量</td>
</tr>
</tbody></table>
<h2 id="Hotspot所提供的回收器"><a href="#Hotspot所提供的回收器" class="headerlink" title="Hotspot所提供的回收器"></a>Hotspot所提供的回收器</h2><p>【hotspot提供的收集器】</p>
<p>两个收集器之间存在连线，那说明它们可以搭配使用。虚拟机所处的区域说明它是属于新生代收集器还是老年代收集器。</p>
<h3 id="1-Serial（SerialMSC）（Copying算法）"><a href="#1-Serial（SerialMSC）（Copying算法）" class="headerlink" title="1. Serial（SerialMSC）（Copying算法）"></a>1. Serial（SerialMSC）（Copying算法）</h3><p>Serial收集器是最基本最古老的收集器，它是一个单线程收集器，并且在它进行垃圾收集时，必须暂停所有用户线程（STW）。</p>
<p>Serial收集器是针对新生代的收集器，采用的是Copying算法。</p>
<h3 id="2-ParNew-（Copying算法）"><a href="#2-ParNew-（Copying算法）" class="headerlink" title="2. ParNew （Copying算法）"></a>2. ParNew （Copying算法）</h3><p>ParNew收集器是新生代收集器，Serial收集器的多线程版本。使用多个线程进行垃圾收集，在多核CPU环境下有着比Serial更好的表现。</p>
<h3 id="3-Parallel-Scavenge-（Copying算法）"><a href="#3-Parallel-Scavenge-（Copying算法）" class="headerlink" title="3. Parallel Scavenge （Copying算法）"></a>3. Parallel Scavenge （Copying算法）</h3><p>Parallel Scavenge收集器是一个新生代的多线程收集器（并行收集器），它在回收期间<strong>不需要暂停其他用户线程</strong>。</p>
<p>其采用的是Copying算法，该收集器与前两个收集器有所不同，它主要是为了达到一个<strong>可控的吞吐量</strong>。追求高吞吐量，高效利用CPU。吞吐量一般为99%。 也被称为“吞吐量优先收集器”。</p>
<p>吞吐量&#x3D; 用户线程时间&#x2F;(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。</p>
<h3 id="4-Serial-Old-（标记—整理算法）"><a href="#4-Serial-Old-（标记—整理算法）" class="headerlink" title="4. Serial Old （标记—整理算法）"></a>4. Serial Old （标记—整理算法）</h3><p>Serial Old收集器是针对老年代的收集器，采用的是Mark-Compact算法。它的优点是实现简单高效，但是缺点是会给用户带来停顿。</p>
<h3 id="5-Parallel-Old（ParallelMSC）（标记—整理算法）"><a href="#5-Parallel-Old（ParallelMSC）（标记—整理算法）" class="headerlink" title="5. Parallel Old（ParallelMSC）（标记—整理算法）"></a>5. Parallel Old（ParallelMSC）（标记—整理算法）</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和Mark-Compact算法。吞吐量优先。</p>
<h3 id="6-CMS（标记—清除算法）"><a href="#6-CMS（标记—清除算法）" class="headerlink" title="6. CMS（标记—清除算法）"></a>6. CMS（标记—清除算法）</h3><p>CMS（Current Mark Sweep）收集器是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器，它是一种并发收集器，采用的是Mark-Sweep算法。</p>
<p>收集过程：</p>
<ol>
<li>初始标记，标记GCRoots能直接关联到的对象，时间很短。</li>
<li>并发标记，进行GCRoots Tracing（可达性分析）过程，时间很长。</li>
<li>重新标记，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间较长。</li>
<li>并发清除，回收内存空间，时间很长。</li>
</ol>
<p>其中，并发标记与并发清除小号时间长，但是可以和用户线程并发执行。如下图：</p>
<p>【CMS收集器】</p>
<p>高并发、低停顿，追求最短GC回收停顿时间，CPU占用比较高。响应时间快，停顿时间短，多核CPU 追求高响应时间的选择。</p>
<p>缺点：</p>
<ul>
<li>对CPU资源非常敏感，可能会导致应用程序变慢，吞吐率下降。</li>
<li>无法处理浮动垃圾。因为在并发清理阶段用户线程还在运行，自然就会产生新的垃圾，而在此次收集中无法收集他们，只能留到下次收集，这部分垃圾为浮动垃圾。</li>
<li>同时，由于用户线程并发执行，所以需要预留一部分老年代空间提供并发收集时程序运行使用。</li>
<li>由于采用的标记 - 清除算法，会产生大量的内存碎片，不利于大对象的分配，可能会提前触发一次Full GC。</li>
</ul>
<h3 id="7-G1（标记-整理）"><a href="#7-G1（标记-整理）" class="headerlink" title="7. G1（标记-整理）"></a>7. G1（标记-整理）</h3><p>  特点：</p>
<ul>
<li><p>并行和并发。使用多个CPU来缩短Stop The World停顿时间，与用户线程并发执行。</p>
</li>
<li><p>分代收集。独立管理整个堆，但是能够采用不同的方式去处理新创建对象和已经存活了一段时间、熬过多次GC的旧对象，以获取更好的收集效果。</p>
</li>
<li><p>空间整合。基于标记 - 整理算法，无内存碎片产生。</p>
</li>
<li><p>可预测的停顿。能简历可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p>
<p>G1垃圾回收器适用于堆内存很大的情况，他将堆内存分割成不同的区域，并且并发的对其进行垃圾回收。</p>
</li>
</ul>
<h2 id="与垃圾回收相关的两个方法"><a href="#与垃圾回收相关的两个方法" class="headerlink" title="与垃圾回收相关的两个方法"></a>与垃圾回收相关的两个方法</h2><h3 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h3><p> 命令行参数监视垃圾收集器的运行：</p>
<p>不管JVM使用的是哪一种垃圾回收的算法，都可以请求Java的垃圾回收。在命令行中有一个参数<code>-verbosegc</code>可以查看Java使用的堆内存的情况，它的格式如下：</p>
<p><code>java -verbosegc classfile</code></p>
<p><strong>注</strong>：调用System.gc()也仅仅是一个请求(建议)。JVM接受这个消息后，并不是立即做垃圾回收，而只是对几个垃圾回收算法做了加权，使垃圾回收操作容易发生，或提早发生，或回收较多而已。</p>
<h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><p>在JVM垃圾回收器收集一个对象之前，一般要求程序调用适当的方法释放资源。但在没有明确释放资源的情况下，Java提供了缺省机制来终止该对象以释放资源，这个方法就是<code>finalize()</code></p>
<p><strong>why finalize()?</strong></p>
<p>存在着垃圾回收器不能处理的特殊情况。如的对象（并非使用new方法）获得了一块“特殊”的内存区域（如类c空间分配、打开的文件资源），而垃圾回收器只知道那些显示地经由new分配的内存空间。</p>
<p>一旦垃圾回收器准备好释放对象占用的存储空间，首先会去调用<code>finalize()</code>方法进行一些必要的清理工作。只有到下一次再进行垃圾回收动作的时候，才会真正释放这个对象所占用的内存空间。</p>
<p>当 <code>finalize() </code>方法被调用时，JVM 会释放该线程上的所有同步锁。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5261a62e4d29">浅析JAVA的垃圾回收机制（GC）</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/blogs/296981">万字长文！深入详解Java垃圾回收（GC）机制</a></p>
<p><a target="_blank" rel="noopener" href="https://javapapers.com/java/types-of-java-garbage-collectors/">Types of Java Garbage Collectors</a></p>

    </div>

    
    
    

    
      <div>
       <div>
    
        <div style="text-align:center;color: #3F92A4;font-size:15px;">-------------END OF TEXT <i class="fa fa-tree"></i> Thanks for reading(●'◡'●)-------------</div>
    
</div>
      </div>
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Mooyi
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://mooyi646.github.io/post/1134db17.html" title="GC">https://mooyi646.github.io/post/1134db17.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" rel="tag"># GC垃圾回收</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/post/4b1b8bf7.html" rel="prev" title="多线程与锁">
      <i class="fa fa-chevron-left"></i> 多线程与锁
    </a></div>
      <div class="post-nav-item">
    <a href="/post/f8355b15.html" rel="next" title="leetcode记录">
      leetcode记录 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Garbage-Collection-GC"><span class="nav-number">1.</span> <span class="nav-text">Garbage Collection(GC)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">引用类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8StrongReference"><span class="nav-number">1.1.1.</span> <span class="nav-text">强引用StrongReference</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8SoftReference"><span class="nav-number">1.1.2.</span> <span class="nav-text">软引用SoftReference</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8WeakReference"><span class="nav-number">1.1.3.</span> <span class="nav-text">弱引用WeakReference</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8PhantomReference"><span class="nav-number">1.1.4.</span> <span class="nav-text">虚引用PhantomReference</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E2%80%9C%E5%9E%83%E5%9C%BE%E2%80%9D"><span class="nav-number">1.2.</span> <span class="nav-text">判断“垃圾”</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95Reference-Counting-Collector"><span class="nav-number">1.2.1.</span> <span class="nav-text">引用计数法Reference Counting Collector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95Tracing-Collector"><span class="nav-number">1.2.2.</span> <span class="nav-text">根搜索算法Tracing Collector</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95Mark-Sweep"><span class="nav-number">1.3.1.</span> <span class="nav-text">标记-清除算法Mark-Sweep</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95Mark-Compact"><span class="nav-number">1.3.2.</span> <span class="nav-text">标记-整理算法Mark-Compact</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95Copying"><span class="nav-number">1.3.3.</span> <span class="nav-text">复制算法Copying</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Adaptive%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.4.</span> <span class="nav-text">Adaptive算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98"><span class="nav-number">1.4.</span> <span class="nav-text">堆内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8C%BA%E5%9F%9F"><span class="nav-number">1.4.1.</span> <span class="nav-text">堆内存分配区域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3Young-Generation"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">新生代Young Generation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3Old-Generation"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">老年代Old Generation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E4%BB%A3Persistence-Generation"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">持久代Persistence Generation</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">1.5.</span> <span class="nav-text">垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8Serial"><span class="nav-number">1.5.1.</span> <span class="nav-text">串行垃圾回收器Serial</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8Parallel"><span class="nav-number">1.5.2.</span> <span class="nav-text">并行垃圾回收器Parallel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E6%89%AB%E6%8F%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8CMS"><span class="nav-number">1.5.3.</span> <span class="nav-text">并发标记扫描垃圾回收器CMS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8Garbage-First"><span class="nav-number">1.5.4.</span> <span class="nav-text">G1垃圾回收器Garbage First</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="nav-number">1.6.</span> <span class="nav-text">JVM配置参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hotspot%E6%89%80%E6%8F%90%E4%BE%9B%E7%9A%84%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">1.7.</span> <span class="nav-text">Hotspot所提供的回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Serial%EF%BC%88SerialMSC%EF%BC%89%EF%BC%88Copying%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">1.7.1.</span> <span class="nav-text">1. Serial（SerialMSC）（Copying算法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-ParNew-%EF%BC%88Copying%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">1.7.2.</span> <span class="nav-text">2. ParNew （Copying算法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Parallel-Scavenge-%EF%BC%88Copying%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">1.7.3.</span> <span class="nav-text">3. Parallel Scavenge （Copying算法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Serial-Old-%EF%BC%88%E6%A0%87%E8%AE%B0%E2%80%94%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">1.7.4.</span> <span class="nav-text">4. Serial Old （标记—整理算法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Parallel-Old%EF%BC%88ParallelMSC%EF%BC%89%EF%BC%88%E6%A0%87%E8%AE%B0%E2%80%94%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">1.7.5.</span> <span class="nav-text">5. Parallel Old（ParallelMSC）（标记—整理算法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-CMS%EF%BC%88%E6%A0%87%E8%AE%B0%E2%80%94%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">1.7.6.</span> <span class="nav-text">6. CMS（标记—清除算法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-G1%EF%BC%88%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%EF%BC%89"><span class="nav-number">1.7.7.</span> <span class="nav-text">7. G1（标记-整理）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="nav-number">1.8.</span> <span class="nav-text">与垃圾回收相关的两个方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#System-gc"><span class="nav-number">1.8.1.</span> <span class="nav-text">System.gc()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#finalize"><span class="nav-number">1.8.2.</span> <span class="nav-text">finalize()</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mooyi"
      src="https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281528071.png">
  <p class="site-author-name" itemprop="name">Mooyi</p>
  <div class="site-description" itemprop="description">Live with fun</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Mooyi646" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Mooyi646" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/mooyixh@gmail.com" title="E-Mail → mooyixh@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/LuoMooyi" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;LuoMooyi" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>FB Page</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/m00y1h" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;m00y1h" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="Link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://google.com/" title="http:&#x2F;&#x2F;google.com" rel="noopener" target="_blank">Google</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://bing.com/" title="http:&#x2F;&#x2F;bing.com" rel="noopener" target="_blank">Bing</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-07 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mooyi</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">151k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">2:17</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://mooyi.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://mooyi646.github.io/post/1134db17.html";
    this.page.identifier = "post/1134db17.html";
    this.page.title = "GC";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://mooyi.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
