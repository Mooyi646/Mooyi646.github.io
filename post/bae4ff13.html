<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281527777.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281527777.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281527777.png">
  <link rel="mask-icon" href="https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281527777.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mooyi646.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="Redis特点：高性能的key-value数据库，NoSQL 与其他key-value数据库相比：  redis支持数据持久化，可以将内存中的数据保存在磁盘中，重启时再次加载使用。 除简单数据外，还支持list, set, zset(有序set), hash等数据结构的存储 支持数据备份，即master-slave模式的数据备份">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="https://mooyi646.github.io/post/bae4ff13.html">
<meta property="og:site_name" content="Mooyi&#39;s Blog">
<meta property="og:description" content="Redis特点：高性能的key-value数据库，NoSQL 与其他key-value数据库相比：  redis支持数据持久化，可以将内存中的数据保存在磁盘中，重启时再次加载使用。 除简单数据外，还支持list, set, zset(有序set), hash等数据结构的存储 支持数据备份，即master-slave模式的数据备份">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-12-13T11:14:15.000Z">
<meta property="article:modified_time" content="2023-12-13T11:18:16.214Z">
<meta property="article:author" content="Mooyi">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://mooyi646.github.io/post/bae4ff13.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Redis | Mooyi's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mooyi's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://mooyi646.github.io/post/bae4ff13.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281528071.png">
      <meta itemprop="name" content="Mooyi">
      <meta itemprop="description" content="Live with fun">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mooyi's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis
        </h1>

        <div class="post-meta">

        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-12-13 19:14:15 / Modified: 19:18:16" itemprop="dateCreated datePublished" datetime="2023-12-13T19:14:15+08:00">2023-12-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learning/" itemprop="url" rel="index"><span itemprop="name">Learning</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learning/DataBase/" itemprop="url" rel="index"><span itemprop="name">DataBase</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/post/bae4ff13.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="post/bae4ff13.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>21 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>特点：高性能的<code>key-value</code>数据库，NoSQL</p>
<p>与其他<code>key-value</code>数据库相比：</p>
<ul>
<li>redis支持数据持久化，可以将内存中的数据保存在磁盘中，重启时再次加载使用。</li>
<li>除简单数据外，还支持<code>list</code>, <code>set</code>, <code>zset</code>(有序set), <code>hash</code>等数据结构的存储</li>
<li>支持数据备份，即master-slave模式的数据备份</li>
</ul>
<span id="more"></span>

<p>优势：</p>
<ul>
<li>性能极高</li>
<li>丰富的数据类型</li>
<li>原子：所有操作都是原子性的</li>
<li>丰富的特性：还支持publish&#x2F;subscribe，通知，key过期等特性</li>
</ul>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>支持五种数据基础类型：</p>
<ul>
<li>string</li>
<li>hash</li>
<li>list</li>
<li>set</li>
<li>zset(sorted set)</li>
</ul>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>是redis最基本的类型。值最大能存储<code>512MB</code></p>
<p>是二进制安全的，即redis的<code>string</code>可以包含任何数据。</p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置key-value类型的值</span></span><br><span class="line">SET test &quot;test&quot;</span><br><span class="line">GET test</span><br><span class="line">&quot;test&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量设置/获取时可以用MSET / MGET</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断某个key是否存在</span></span><br><span class="line">EXISTS test</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回key对应的字符串的长度</span></span><br><span class="line">STRLEN test</span><br><span class="line">(integer) 4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除key对应值</span></span><br><span class="line">DEL test</span><br></pre></td></tr></table></figure>



<p>实现计数器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当字符串内容为整数时可使用</span></span><br><span class="line">SET number 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">增加</span></span><br><span class="line">INCR number</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">INCRBY number 10</span><br><span class="line">(integer) 11</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">减少</span></span><br><span class="line">DECR number</span><br><span class="line">(integer) 10</span><br><span class="line"></span><br><span class="line">DECRE number 10</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<p>过期（默认永不过期）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置key 60s后过期（已存在的key）</span></span><br><span class="line">EXPIRE test 60</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看还有多久过期</span></span><br><span class="line">TTL test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置 key-value 类型的值，并设置该key的过期时间为 60 秒</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SET key  value EX 60</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SETEX key  60 value</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不存在就插入（not exists）</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">SETNX key value</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>



<h4 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h4><p>string底层的数据结构实现主要是<code>int</code>和<code>SDS</code>(简单动态字符串)</p>
<p>SDS相比C语言字符串：</p>
<ul>
<li>SDS不仅可以保存文本数据，还可以保存二进制数据。因为SDS使用<code>len</code>来判断字符串长度而不是空字符<code>\0</code></li>
<li>SDS获取字符串长度的时间复杂度是$O(1)$，因为其使用了<code>len</code>属性来记录长度</li>
<li>SDS是API安全的，拼接字符串不会造成缓冲区溢出，因为拼接之前会检查SDS空间是否满足要求，不够会扩容。</li>
</ul>
<p>SDS共有五种类型：sdshdr5实际并不会使用。redis会根据初始化长度决定使用哪种类型，从而减少内存使用。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节</th>
<th>位</th>
</tr>
</thead>
<tbody><tr>
<td>sdshdr5</td>
<td>&lt; 1</td>
<td>&lt;8</td>
</tr>
<tr>
<td>sdshdr8</td>
<td>1</td>
<td>8</td>
</tr>
<tr>
<td>sdshdr16</td>
<td>2</td>
<td>16</td>
</tr>
<tr>
<td>sdshdr32</td>
<td>4</td>
<td>32</td>
</tr>
<tr>
<td>sdshdr64</td>
<td>8</td>
<td>64</td>
</tr>
</tbody></table>
<p>对于后四种实现都包含了下面这 4 个属性：</p>
<ul>
<li><code>len</code>：字符串的长度也就是已经使用的字节数</li>
<li><code>alloc</code>：总共可用的字符空间大小，alloc-len 就是 SDS 剩余的空间大小</li>
<li><code>buf[]</code>：实际存储字符串的数组</li>
<li><code>flags</code>：低三位保存类型标志</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="缓存对象"><a href="#缓存对象" class="headerlink" title="缓存对象"></a>缓存对象</h5><p>有两种方式：</p>
<ul>
<li><p>直接缓存整个对象的json，如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET user:1 &#x27;&#123;&quot;name&quot;: &quot;Jack&quot;, &quot;age&quot;: 11&#125;&#x27;</span><br></pre></td></tr></table></figure>


</li>
<li><p>采用将key进行分离为对象字段，使用MSET存储，即为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSET user:1:name &quot;Jack&quot; user:1:age 11</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="常规计数"><a href="#常规计数" class="headerlink" title="常规计数"></a>常规计数</h5><p>redis命令都是原子的，所以string类型可以用于计数</p>
<p>如可用于计算访问次数、点赞、转发数等</p>
<p>使用<code>INCR</code>即可</p>
<h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h5><p><code>SET</code>有个参数为<code>NX</code>，可以实现key不存在才插入，可用于实现分布式锁：</p>
<ul>
<li>若key不存在，则插入成功，可用于表示加锁成功</li>
<li>若key存在，则插入失败，可用于表示加锁失败</li>
</ul>
<p>一般而言，还会对分布式锁加上过期时间(<code>PX</code>，单位为miliseconds)，分布式锁的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock_key unique_value NX PX 10000</span><br></pre></td></tr></table></figure>

<p>解锁的过程即将<code>lock_key</code>删除，删除前需判断锁的<code>unique_value</code>是否为加锁客户端，是的时候才删除。</p>
<p>即解锁有两个过程，需使用Lua脚本来保证解锁的原子性：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h5 id="共享session信息"><a href="#共享session信息" class="headerlink" title="共享session信息"></a>共享session信息</h5><p>例如用户登录的场景，其session信息被存储在server1，第二次访问时用户被分配到server2，就会出现重复登录的问题。问题在于分布式系统每次会把请求随机分配到不同的服务器。</p>
<p>可以借助redis对session信息进行统一的存储和管理。</p>
<p>【借助redis共享session信息【小林】】</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>是一个键值对集合(key-value)。</p>
<p>hash 是一个 string 类型的 <code>field</code> 和 <code>value</code> 的映射表，很适合用于存储对象。</p>
<p>每个hash可以存储$2^{32}-1$个键值对</p>
<h4 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">HSET / HMSET(deprecated)用于设置多个键值对</span></span><br><span class="line">HSET test field1 &quot;value1&quot; field2 &quot;value2&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回对应key指定键值</span></span><br><span class="line">HGET test field1</span><br><span class="line">&quot;value1&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回所有键值</span></span><br><span class="line">HGETALL test</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1) <span class="string">&quot;field1&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2) <span class="string">&quot;value1&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3) <span class="string">&quot;field2&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4) <span class="string">&quot;value2&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除指定键值</span></span><br><span class="line">HDEL test field1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回field数量</span></span><br><span class="line">HLEN test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为指定field值加上增量n(field为数字时)</span></span><br><span class="line">HINCREBY key field n</span><br></pre></td></tr></table></figure>



<h4 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h4><p>底层数据结构为<code>压缩列表</code>或<code>哈希表</code></p>
<p>7.0后压缩列表废弃，使用<code>listpack(紧凑列表)</code>实现</p>
<ul>
<li>元素个数小于512，所有值小于64字节，使用压缩表</li>
<li>否则使用哈希表</li>
</ul>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="存储对象"><a href="#存储对象" class="headerlink" title="存储对象"></a>存储对象</h5><p>非常适合存储对象，如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET user:1 name &quot;Tom&quot; age &quot;11&quot;</span><br></pre></td></tr></table></figure>

<p><strong>string(json)还是hash来存储对象？</strong></p>
<ul>
<li>string存放的为序列化后的对象数据，存放的为整个对象，hash对每个对象字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中<em>某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息</em>，Hash 就非常适合。</li>
<li>string存储更节省内存，缓存相同数量的对象数据，string消耗内存约为hash的一半。且存储有多层嵌套的对象更方便。若<em>系统对性能和资源消耗很敏感</em>，string更合适</li>
<li>一般情况用string存储即可</li>
</ul>
<h5 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h5><p>购物车商品频繁修改变动，用hash更合适</p>
<ul>
<li>用户id为key</li>
<li>商品id为field，数量为value</li>
</ul>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<p>最多存储元素数量为$2^{32} - 1$</p>
<h4 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">LPUSH是在头部添加，key不存在时也可以</span></span><br><span class="line">LPUSH test &quot;value1&quot;</span><br><span class="line">LPUSH test &quot;value2&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在头部添加，只有key存在时才有效</span></span><br><span class="line">LPUSHX test &quot;value3&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">尾部添加</span></span><br><span class="line">RPUSH test &quot;value4&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取所有元素</span></span><br><span class="line">LRANGE test 0 -1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">头部移除</span></span><br><span class="line">LPOP test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">尾部移除</span></span><br><span class="line">RPOP test</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：下标：</p>
<ul>
<li>从左到右：0，1，2…</li>
<li>从右到左：-1，-2，-3…</li>
</ul>
<h4 id="内部实现-2"><a href="#内部实现-2" class="headerlink" title="内部实现"></a>内部实现</h4><p>底层数据结构为<code>双向链表</code>或<code>压缩列表</code></p>
<p>3.2后只使用<code>quicklist</code>实现</p>
<p>quicklist实际上为双向链表与压缩列表的混合体。</p>
<p>将链表按段切分，每一段使用ziplist来紧凑存储，多个段之间使用双向指针串接起来。</p>
<h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><p>消息队列存取消息的三个需求：消息保序、处理重复的消息、保证消息可靠性</p>
<p>list与stream都可满足以上三个需求</p>
<p><strong>1. 消息保序</strong></p>
<p>即满足消息先进先出。</p>
<p>可以使用<code>LPUSH + RPOP</code>或<code>RPUSH + LPOP</code>实现</p>
<p>存在潜在的性能风险点。如使用<code>LPUSH + RPOP</code>：</p>
<p>生产者向list中push数据时，其并不会主动通知消费者有新消息写入。消费者想要及时处理消息时，需要不断调用<code>RPOP</code>命令，有新消息时就返回结果，否则返回空值继续循环。</p>
<p>故即使没新消息写入，消费者也需一直调用RPOP，即导致其CPU一直消耗在RPOP命令上，带来不必要的性能损失。</p>
<p>为解决该问题，redis提供<code>BRPOP</code>命令，即阻塞式读取，未读到数据时，自动阻塞，直到有新消息加入队列，再开始读取新数据。</p>
<p><strong>2. 重复消息处理</strong></p>
<p>消费者实现重复消息处理，需实现两个方面的要求：</p>
<ol>
<li>每个消息都要有一个全局的ID</li>
<li>消费者要记录已经处理过的消息的ID。收到新消息时，对比其ID与记录的已处理过的ID，若已处理则不再处理</li>
</ol>
<p>问题：list不会为每个消息生成ID，所以需要为每个消息自定义唯一的全局ID。生成之后，使用<code>LPUSH</code>将消息插入list时，需包含该全局ID。</p>
<p><strong>3. 保证消息可靠性</strong></p>
<p>消息一旦从list中读出，list中就不会留存该消息。在处理消息的过程中出现宕机或故障时，会导致消息未处理完成，想要再次处理时却无法再在list中读取该消息。</p>
<p>为留存消息，list提供命令<code>BRPOPLPUSH</code>，其作用为：让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存</p>
<p>如此，重启后消费者可以在备份list中再次读取到消息</p>
<blockquote>
<p>list作为消息队列的缺陷？</p>
</blockquote>
<p>list不支持多个消费者消费同一条消息，因为消息从list中读取后就被删除了，无法被再次消费。</p>
<p>list不支持消费者组的实现，所以无法多消费者消费同一条消息。不过stream支持消费者组的形式读取。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>是string类型的无序集合。</p>
<p>集合是通过哈希表实现，所以增删改查的复杂度都是$O(1)$</p>
<p>集合中最大的成员数为 $2^{32} - 1$</p>
<h4 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加元素，重复添加元素会被忽略</span></span><br><span class="line">SADD test &quot;value1&quot; &quot;value2&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看集合元素</span></span><br><span class="line">SMEMBERS test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除元素</span></span><br><span class="line">SREM test &quot;value1&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取元素个数</span></span><br><span class="line">SCARD test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断元素是否在集合中</span></span><br><span class="line">SISMEMBER test &quot;value3&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从集合中随机选出count个元素，元素不删除</span></span><br><span class="line">SRANDMEMBER test 2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">元素删除</span></span><br><span class="line">SPOP test 2</span><br></pre></td></tr></table></figure>



<h4 id="运算操作"><a href="#运算操作" class="headerlink" title="运算操作"></a>运算操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">交集运算</span></span><br><span class="line">SINTER key [key ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将交集结果存入新集合destination中</span></span><br><span class="line">SINTERSTORE destination key [key ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并集运算</span></span><br><span class="line">SUNION key [key ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将并集结果存入新集合destination中</span></span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">差集运算</span></span><br><span class="line">SDIFF key [key ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将差集结果存入新集合destination中</span></span><br><span class="line">SDIFFSTORE destination key [key ...]</span><br></pre></td></tr></table></figure>

<p>注：交并差计算复杂度较高$O(n)$，数据量大时会导致redis实例阻塞</p>
<h4 id="内部实现-3"><a href="#内部实现-3" class="headerlink" title="内部实现"></a>内部实现</h4><p>底层数据结构为<code>哈希表</code>或<code>整数集合</code></p>
<ul>
<li>集合元素都为整数且个数小于512时，使用整数集合</li>
<li>其余情况使用哈希表</li>
</ul>
<h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><p>集合的主要几个特性，无序、不可重复、支持并交差等操作。</p>
<h5 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h5><p>利用不可重复性</p>
<p>保证一个用户只能点一个赞。</p>
<p>如用户对某视频点赞：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">点赞</span></span><br><span class="line">SADD video:1 uid:1</span><br><span class="line">SADD video:1 uid:2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取消点赞</span></span><br><span class="line">SREM video:1 uid:1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取点赞总数</span></span><br><span class="line">SCARD video:1 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断用户是否点赞</span></span><br><span class="line">SISMEMBER video:1 uid:4</span><br></pre></td></tr></table></figure>



<h5 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h5><p>利用交并差</p>
<p>set支持交集运算，所以可用户计算共同相关量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SADD uid:1 1 2 3 4 5</span><br><span class="line">SADD uid:2 2 3 6 8 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取其共同关注</span></span><br><span class="line">SINTER uid:1 uid:2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给uid:2 推荐uid:1的关注</span></span><br><span class="line">SDIFF uid1 uid:2</span><br></pre></td></tr></table></figure>



<h5 id="抽奖活动"><a href="#抽奖活动" class="headerlink" title="抽奖活动"></a>抽奖活动</h5><p>利用唯一性，保证同一用户不会中奖两次，且保证随机数据源</p>
<p>key：活动名 value：参与者id</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SADD lucky 1 2 3 4 6 7 8</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许重复抽奖时，可使用SRANDMEMBER</span></span><br><span class="line">SRANDMEMBER lucky 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不允许重复时，使用SPOP</span></span><br><span class="line">SPOP lucky 2</span><br></pre></td></tr></table></figure>



<h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p>有序集合</p>
<p>每个元素都会关联一个double类型的分数，通过分数来增序排列。</p>
<p>成员唯一，但是分数score可重复。</p>
<h4 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加元素</span></span><br><span class="line">ZADD key score value</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如</span></span><br><span class="line">ZADD test 0 &quot;value1&quot;</span><br><span class="line">ZADD test 1 &quot;value2&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回元素分值</span></span><br><span class="line">ZSCORE test &quot;value1&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回元素个数</span></span><br><span class="line">ZCARD test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除元素</span></span><br><span class="line">ZREM test &quot;value1&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">正序获取从start到stop的元素</span></span><br><span class="line">ZRANGE test start stop [WITHSCORES]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">逆序获取</span></span><br><span class="line">ZREVRANGE test start stop [WITHSCORES]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取指定分数区间元素，分数由高到低</span></span><br><span class="line">ZRANGEBYSCORE test min max</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按字典序获取指定区间成员，分数必须相同。分数不同时返回结果不准。倒序使用ZREVRANGEBYLEX</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">min, max必须以[或(开头，可以使用-代替</span></span><br><span class="line">ZRANGEBYLEX test min max</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取指定元素排名（按分数从小到大）</span></span><br><span class="line">ZRANK test &quot;value1&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从大到小</span></span><br><span class="line">ZREVRANK test &quot;value1&quot;</span><br></pre></td></tr></table></figure>

<h4 id="运算操作-1"><a href="#运算操作-1" class="headerlink" title="运算操作"></a>运算操作</h4><p>支持交并，不支持差</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</span></span><br><span class="line">ZUNIONSTORE destkey numberkeys key [key...] </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">交集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</span></span><br><span class="line">ZINTERSTORE destkey numberkeys key [key...]</span><br></pre></td></tr></table></figure>



<h4 id="内部实现-4"><a href="#内部实现-4" class="headerlink" title="内部实现"></a>内部实现</h4><p>底层数据结构使用<code>压缩列表</code>或<code>跳表</code></p>
<ul>
<li>有序元素个数小于128，每个元素值小于64字节，使用压缩列表</li>
<li>否则使用跳表</li>
</ul>
<p>7.0中，压缩列表废弃，使用<code>listpack</code></p>
<p><strong>为什么使用跳表而不是红黑树？</strong></p>
<p>跳表复杂度和红黑树一样都是$O(\log_{2}n)$，但是相对而言，跳表结构更简单，而且更适合zset的<code>ZRANGE</code>操作。</p>
<h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><p>zset可以根据元素权重排序。</p>
<p>适用于显示最新列表（插入时间为权重），排行榜等</p>
<h5 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h5><p>以点赞数为例，某条博文下评论的点赞数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ZADD blogcom:1 300 uid:1</span><br><span class="line">ZADD blogcom:1 200 uid:2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新增点赞</span></span><br><span class="line">ZINCRBY blogcom:1 1 uid:1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看点赞数</span></span><br><span class="line">ZSCORE blogcom:1 uid:1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看点赞数最多的三条</span></span><br><span class="line">ZREVRANGE blogcom:1 0 2 WITHSCORES</span><br></pre></td></tr></table></figure>



<h2 id="特殊数据类型"><a href="#特殊数据类型" class="headerlink" title="特殊数据类型"></a>特殊数据类型</h2><h3 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h3><p>即位图，是一串连续的二进制数组，可以通过偏移量(offset)定位元素。</p>
<p>bitmap通过最小的单位bit来进行<code>0/1</code>的设置，表示某个元素的值或状态，时间复杂度为$O(1)$</p>
<p>使用bit存储非常节省空间，适合大数量量且使用二值统计的场景。</p>
<h4 id="常用命令-5"><a href="#常用命令-5" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置值，value只能为0, 1</span></span><br><span class="line">SETBIT key offset value</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取值</span></span><br><span class="line">GETBIT key offset</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取指定范围内1的个数，start和end以字节为单位，-1表示最后一个字节</span></span><br><span class="line">BITCOUNT key start end</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">a: 0110 0001</span>	</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">b: 0110 0010</span>	</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">c: 0110 0011</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mykey: 01100001 01100010 01100011</span></span><br><span class="line">127.0.0.1:6379&gt; set mykey &#x27;abc&#x27;</span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计整个字符串对应的bit=1的数量</span></span><br><span class="line">127.0.0.1:6379&gt; bitcount mykey</span><br><span class="line">(integer) 10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">a</span></span><br><span class="line">127.0.0.1:6379&gt; bitcount mykey 0 0</span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ab</span></span><br><span class="line">127.0.0.1:6379&gt; bitcount mykey 0 1</span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure>



<h4 id="运算操作-2"><a href="#运算操作-2" class="headerlink" title="运算操作"></a>运算操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">BitMap间的运算</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">operations 位移操作符，枚举值</span></span><br><span class="line">  AND 与运算 &amp;</span><br><span class="line">  OR 或运算 |</span><br><span class="line">  XOR 异或 ^</span><br><span class="line">  NOT 取反 ~</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">result 计算的结果，会存储在该key中</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">key1 … keyn 参与运算的key，可以有多个，空格分割，not运算只能一个key</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0。返回值是保存到 destkey 的字符串的长度（以字节byte为单位），和输入 key 中最长的字符串长度相等。</span></span><br><span class="line">BITOP [operations] [result] [key1] [keyn…]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回指定key中第一次出现指定value(0/1)的位置</span></span><br><span class="line">BITPOS [key] [value]</span><br></pre></td></tr></table></figure>





<h4 id="内部实现-5"><a href="#内部实现-5" class="headerlink" title="内部实现"></a>内部实现</h4><p>其底层数据结构为<code>string</code>，string是会保存为<code>二进制的字节数组</code>，所以，redis将字节数组的每个bit位都利用起来，用来表示一个元素的二值状态。可以将Bitmap看作一个<code>bit数组</code>。</p>
<p>所以可以使用string值来set，其会自动转换为对应的ascii的二进制值。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以直接使用string来<span class="built_in">set</span>，会转换为其对应的ascii二进制，如可以：</span></span><br><span class="line">SET key 42</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">42为：4为52，2为50 即为00110100 00110010</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后可以通过GETBIT获取值</span></span><br></pre></td></tr></table></figure>



<h4 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h4><p>适合二值(0&#x2F;1)状态统计的场景</p>
<h5 id="签到统计"><a href="#签到统计" class="headerlink" title="签到统计"></a>签到统计</h5><p>只记录签到(1)和未签到(0)</p>
<p>每个用户每天的签到情况只需用一个bit为表示</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">记录6.3号签到</span></span><br><span class="line">SETBIT uid:1:202306 2 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询是否已签到</span></span><br><span class="line">GETBIT uid:1:202306 2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计签到次数</span></span><br><span class="line">BITCOUNT uid:1:202306</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询这个月第一次打卡的日期</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提供了：BITPOS key value [start] [end]范围第一次出现value的offset位置</span></span><br><span class="line">BITPOS uid:1:202306 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回的值需+1</span></span><br></pre></td></tr></table></figure>



<h5 id="判断用户登录状态"><a href="#判断用户登录状态" class="headerlink" title="判断用户登录状态"></a>判断用户登录状态</h5><p>基本同上</p>
<h5 id="连续签到用户总数"><a href="#连续签到用户总数" class="headerlink" title="连续签到用户总数"></a>连续签到用户总数</h5><p>统计出连续7天签到用户总数</p>
<ol>
<li>将每天的日期作为key，uid为offset，打卡值为1。则每个key表示某天用户的打卡记录</li>
<li>统计某7天，则对应有7个如此的bitmap，将这7天对应的Bit位做与运算，若全为1则说明连续打卡。</li>
<li>将结果保存至新的bitmap中，然后使用BITCOUNT计算总数</li>
</ol>
<p>使用<code>BITOP [operations] [result] [key1] [keyn…]</code>进行位操作</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计7天</span></span><br><span class="line">BITOP AND destmap bitmap:1 bitmap:2 bitmap:3 bitmap:4 bitmap:5 bitmap:6 bitmap:7</span><br><span class="line">BITCOUNT destmap</span><br></pre></td></tr></table></figure>

<p>同时可以为每天的bitmap设置过期时间，节省内存</p>
<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>是用于做基数（不同数据个数）统计的算法。【不精确】</p>
<p>优点：在输入元素的数量或体积非常大时，计算基数所需空间总是固定的、很小的。</p>
<p>只会根据输入元素来计算基数，不会储存元素本身，所以不能返回元素。</p>
<h4 id="常用命令-6"><a href="#常用命令-6" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加元素</span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">PFADD <span class="built_in">test</span> 1 2 4 3 2 1</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回基数估算值</span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">PFCOUNT <span class="built_in">test</span></span></span><br><span class="line">(integer) 4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">PFADD test2 2 4 5 6</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">PFCOUNT test2</span></span><br><span class="line">(integer) 4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并</span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">PFMERGE testall <span class="built_in">test</span> test2</span></span><br><span class="line">&quot;OK&quot;</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">PFCOUNT testall</span></span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure>

<p>使用场景：</p>
<ul>
<li>用于统计注册IP、访问IP数，在线用户数、搜索词条数量。即数据量比较大的，需要统计总数的场景。</li>
</ul>
<h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><p>3.2版本新增，用于存储地理位置信息，并对存储的信息进行操作。</p>
<h4 id="常用命令-7"><a href="#常用命令-7" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存储指定的地理空间位置，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key 中。</span></span><br><span class="line">GEOADD key longitude latitude member [longitude latitude member ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从给定的 key 里返回所有指定名称(member)的位置（经度和纬度），不存在的返回 nil。</span></span><br><span class="line">GEOPOS key member [member ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回两个给定位置之间的距离。</span></span><br><span class="line">GEODIST key member1 member2 [m|km|ft|mi]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</span></span><br><span class="line">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">WITHDIST: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">WITHCOORD: 将位置元素的经度和纬度也一并返回。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">COUNT 限定返回的记录数。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ASC: 查找结果根据距离从近到远排序。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">DESC: 查找结果根据从远到近排序。</span></span><br></pre></td></tr></table></figure>



<h4 id="内部实现-6"><a href="#内部实现-6" class="headerlink" title="内部实现"></a>内部实现</h4><p>底层直接使用了<code>Sorted Set</code></p>
<p>使用GeoHash编码方法实现了经纬度到sorted set中元素权重分数的转换，这其中的两个关键机制就是「对二维地图做区间划分」和「对区间进行编码」。一组经纬度落在某个区间后，就用区间的编码值来表示，并把编码值作为 Sorted Set 元素的权重分数。</p>
<p>这样一来，我们就可以把经纬度保存到 Sorted Set 中，利用 Sorted Set 提供的“按权重进行有序范围查找”的特性，实现 LBS(Location-Based Service) 服务中频繁使用的“搜索附近”的需求。</p>
<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>打车</p>
<p>假设车辆 ID 是 33，经纬度位置是（116.034579，39.030452），我们可以用一个 GEO 集合保存所有车辆的经纬度，集合 key 是 cars:locations。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOADD cars:locations 116.034579 39.030452 33</span><br></pre></td></tr></table></figure>

<p>当用户想要寻找自己附近的网约车时，LBS 应用就可以使用 GEORADIUS 命令。</p>
<p>如以下，Redis 会根据输入的用户的经纬度信息（116.054579，39.030452 ），查找以这个经纬度为中心的 5 公里内的车辆信息，并返回给 LBS 应用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEORADIUS cars:locations 116.054579 39.030452 5 km ASC COUNT 10</span><br></pre></td></tr></table></figure>



<h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p>pub&#x2F;sub是一种消息通信模式</p>
<p>redis客户端可以订阅任意数量的频道</p>
<p>【发布订阅图示】</p>
<p>有新消息通过PUBLISH命令发送给频道channel1时，该消息会被发送给订阅它的三个客户端</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">订阅频道</span></span><br><span class="line">SUBSCRIBE testChannel</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发布消息</span></span><br><span class="line">PUBLISH testChannel &quot;this is a message&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">订阅的客户端会受到</span></span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;testChannel&quot;</span><br><span class="line">3) &quot;this is a message&quot;</span><br></pre></td></tr></table></figure>

<p>注：pub&#x2F;sub可以分发消息，但是无法记录历史消息</p>
<p><strong>发布&#x2F;订阅机制为什么不可做消息队列？</strong></p>
<p>数据丢失</p>
<ul>
<li>不具备数据持久化能力，即其相关操作不会写入到RDB和AOF中，redis宕机后，其数据会全部丢失</li>
<li>是“发后即忘”的工作模式，有订阅者离线重连后不能消费之前的历史消息。</li>
<li>消费端有一定的消息积压时，若超过32M或60s内持续保持8M以上，消费端会被强行断开。该参数在配置文件中：<code>client-output-buffer-limit pubsub 32mb 8mb 60</code></li>
</ul>
<p>故发布订阅机制只适合即时通讯的场景。如构建哨兵集群的场景就使用了发布订阅机制。</p>
<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>5.0新增，主要用于消息队列（MQ，Message Queue）</p>
<p>支持消息的持久化、支持自动生成全局唯一 ID、支持 ack 确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠。</p>
<p>提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p>
<p>其结构如下，有一个消息链表，将所有加入的消息都串起来，每个消息都有唯一的ID与对应的内容：</p>
<p>【stream结构】</p>
<p>每个 Stream 都有唯一的名称，它就是 Redis 的 key，在我们首次使用<code> xadd</code> 指令追加消息时自动创建。</p>
<ul>
<li>Consumer Group ：消费组，使用 <code>XGROUP CREATE</code> 命令创建，一个消费组有多个消费者(Consumer)。</li>
<li>last_delivered_id ：游标，每个消费组会有个游标 last_delivered_id，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。</li>
<li>pending_ids：消费者(Consumer)的状态变量，作用是维护消费者的未确认的 id。 pending_ids 记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符）。</li>
</ul>
<h3 id="消息队列相关命令："><a href="#消息队列相关命令：" class="headerlink" title="消息队列相关命令："></a>消息队列相关命令：</h3><ul>
<li><p><code>XADD</code> - 添加消息到末尾吗，队列不存在时自动创建队列</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XADD key ID field value [field value ...]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>key：队列名称</p>
</li>
<li><p>ID：消息ID，使用<code>*</code>表示redis自动生成。自定义时需保证递增性</p>
<p>自动生成的id如：<code>&quot;1654254953808-0&quot;</code>,其中前半部分为数据插入时，以毫秒为单位计算的当前服务器时间；后半部分为该毫秒内的第1条消息</p>
</li>
<li><p>field value ：记录</p>
</li>
</ul>
</li>
<li><p><code>XTRIM</code> - 对流进行修剪，限制长度</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XTRIM key MAXLEN [~] count</span><br></pre></td></tr></table></figure>

<ul>
<li>MAXLEN：长度</li>
<li>count：数量</li>
<li><code>~</code>：并不是精确要求count条，但是绝不能少于count；可以提高效率</li>
</ul>
</li>
<li><p><code>XDEL</code> - 删除消息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XDEL key ID [ID ...]</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>XLEN</code>- 获取流包含的元素数量，即消息长度</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XLEN key</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>XRANGE</code> - 获取消息列表，会自动过滤已经删除的消息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XRANGE key start end [COUNT count]</span><br></pre></td></tr></table></figure>

<ul>
<li>start：<code>-</code>表示最小值</li>
<li>end：<code>+</code>表示最大值</li>
</ul>
</li>
<li><p><code>XREVRANGE</code> - 反向获取消息列表，ID 从大到小</p>
<p>语法用XRANGE</p>
</li>
<li><p><code>XREAD</code>- 以阻塞或非阻塞方式获取消息列表</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREAD [COUNT count] [BLOCK miliseconds] STREAMS key [key ...] id [id ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>miliseconds：阻塞毫秒数，可选，无就是默认非阻塞模式</li>
<li>从指定id的消息开始读取</li>
</ul>
</li>
</ul>
<p>以上操作使用list也可以实现，而消费者组是stream所特有的。</p>
<h3 id="消费组相关命令"><a href="#消费组相关命令" class="headerlink" title="消费组相关命令"></a>消费组相关命令</h3><ul>
<li><p><code>XGROUP CREATE</code> - 创建消费者组</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP [CREATE key groupname id-or-$] </span><br></pre></td></tr></table></figure>

<ul>
<li><code>$</code>：表示从尾部开始消费，只接受新消息，当前stream的消息会被全部忽略</li>
<li>id为0时表示从所有历史消息开始</li>
</ul>
</li>
<li><p><code>XREADGROUP GROUP</code> - 读取消费者组中的消息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure>

<p>从指定ID的消息开始读取：使用<code>&gt;</code>表示从第一条尚未被消费的消息开始读取</p>
<p><strong>注</strong>：【消息队列中的消息一旦被消费者组中的一个消费者读取了，就不能再被该消费者组中其他消费者读取，即同一消费者组中的消费者不能消费同一条消息。】</p>
<p>【但是可以被不同消费者组中的消费者读取（但是有前提条件，创建消息组的时候，不同消费组指定了相同位置开始读取消息）。】</p>
<p>使用消费组的目的是让组内的多个消费者共同分担读取消息，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的。</p>
</li>
<li><p><code>XACK</code> - 将消息标记为”已处理”</p>
</li>
<li><p><code>XGROUP DELCONSUMER</code> - 删除消费者</p>
</li>
<li><p><code>XGROUP DESTROY</code> - 删除消费者组</p>
</li>
<li><p><code>XPENDING</code> - 显示待处理消息的相关信息</p>
</li>
<li><p><code>XINFO</code> - 查看流和消费者组的相关信息；</p>
</li>
<li><p><code>XINFO GROUPS</code> - 打印消费者组的信息；</p>
</li>
<li><p><code>XINFO STREAM</code> - 打印流信息</p>
</li>
</ul>
<p><strong>基于 Stream 实现的消息队列，如何保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息？</strong></p>
<p>Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用<code>XACK</code>命令通知 Streams“消息已经处理完成”。</p>
<p>消费确认增加了消息的可靠性，一般在业务处理完成之后，需要执行<code> XACK</code> 命令确认消息已经被消费完成</p>
<p>【消费可靠图示】</p>
<p>如果消费者没有成功处理消息，它就不会给 Streams 发送 <code>XACK</code> 命令，消息仍然会留存。此时，消费者可以在重启后，用 <code>XPENDING </code>命令查看已读取、但尚未确认处理完成的消息。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>专业的消息队列需满足：</p>
<ul>
<li>消息不丢</li>
<li>消息可堆积</li>
</ul>
<p><strong>1. redis消息会丢失吗？</strong></p>
<p>消息队列三大块：</p>
<ul>
<li>生产者</li>
<li>队列中间件</li>
<li>消费者</li>
</ul>
<p>想要保证消息不丢失，即保证以上三个环节消息都不丢失</p>
<p>【三个环节图示】</p>
<ul>
<li>生产者：生产者是否会丢失消息，取决于生产者对异常情况的处理是否合理。从消息生产到提交给MQ，只要能正常收到MQ中间件的ack确认响应，就表示发送成功，所以只需处理好返回值和异常，返回异常则进行消息重发，则此阶段不会出现消息丢失。</li>
<li>消费者：不会丢失消息。因为stream(MQ中间件)会自动使用内部队列(pending list)留存消费组中每个消费者读取但未被确认的消息。消费者重启后，用<code>XPENDING</code>查看已被读取，但未确认处理完成的消息，等其执行完业务逻辑后，再发送消费确认<code>XACK</code>命令，消息不会丢失。</li>
<li>消息中间件：会丢失消息。redis在以下两个场景，都会导致消息丢失：<ul>
<li>AOF持久化配置为每秒写盘，但该写过程是异步的，redis宕机时可能存在数据丢失的可能</li>
<li>主从复制也是异步的，主从切换时，也存在数据丢失的可能。</li>
</ul>
</li>
</ul>
<p>类似kafka这样的专业队列中间件，使用时部署一个集群，其中一个节点挂了也不会导致数据丢失</p>
<p><strong>2. redis消息可堆积吗？</strong></p>
<p>Redis 的数据都存储在内存中，这就意味着一旦发生消息积压，则会导致 Redis 的内存持续增长，如果超过机器内存上限，就会面临被 OOM 的风险。</p>
<p>所以 Redis 的 Stream 提供了可以指定队列最大长度的功能，就是为了避免这种情况发生。</p>
<p>当指定队列最大长度时，队列长度超过上限后，旧消息会被删除，只保留固定长度的新消息。这么来看，Stream 在消息积压时，如果指定了最大长度，还是有可能丢失消息的。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务可以一次执行多条命令，并有以下保证：</p>
<ul>
<li>批量操作在发送 <code>EXEC</code> 命令前被放入队列缓存。</li>
<li>收到 <code>EXEC</code> 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li>
<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li>
</ul>
<p>一个事务从开始到执行的三个阶段：</p>
<ol>
<li>开始事务</li>
<li>命令入队</li>
<li>执行事务</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启事务</span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">MULTI</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令入队</span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SET book-name <span class="string">&quot;Mastering C++ in 21 days&quot;</span></span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">GET book-name</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SADD tag <span class="string">&quot;C++&quot;</span> <span class="string">&quot;Programming&quot;</span> <span class="string">&quot;Mastering Series&quot;</span></span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SMEMBERS tag</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行事务</span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">EXEC</span></span><br><span class="line">1) OK</span><br><span class="line">2) &quot;Mastering C++ in 21 days&quot;</span><br><span class="line">3) (integer) 3</span><br><span class="line">4) 1) &quot;Mastering Series&quot;</span><br><span class="line">   2) &quot;C++&quot;</span><br><span class="line">   3) &quot;Programming&quot;</span><br></pre></td></tr></table></figure>

<p>单个redis命令是原子性的，但是事务执行并不是原子性的。事务类似于批量执行的脚本，但中间命令失败不影响后面指令（无回滚和中断）。</p>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>使用Lua解释器执行脚本，执行常用命令为<code>EVAL</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">EVAL script numkeys key [key ...] arg [arg ...]</span></span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">EVAL <span class="string">&quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot;</span> 2 key1 key2 first second</span></span><br><span class="line"></span><br><span class="line">1) &quot;key1&quot;</span><br><span class="line">2) &quot;key2&quot;</span><br><span class="line">3) &quot;first&quot;</span><br><span class="line">4) &quot;second&quot;</span><br></pre></td></tr></table></figure>



<h2 id="数据备份与恢复"><a href="#数据备份与恢复" class="headerlink" title="数据备份与恢复"></a>数据备份与恢复</h2><p>备份：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">save时阻塞主进程，save完成后，主进程才开始工作</span></span><br><span class="line">SAVE</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以使用BGSAVE，区别是bgsave是在后台执行，fork了一个专门的save子进程，不会影响主进程</span></span><br><span class="line">BGSAVE</span><br></pre></td></tr></table></figure>

<p>会在redis安装目录中创建<code>dump.rdb</code>文件</p>
<p>数据恢复：</p>
<p>只需将<code>dump.rdb</code>文件移动到redis安装目录并启动服务即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取redis安装目录</span></span><br><span class="line">CONFIG GET dir</span><br></pre></td></tr></table></figure>



<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark [option] [option value]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">选项</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">-h</td>
<td align="left">指定服务器主机名</td>
<td align="left">127.0.0.1</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">-p</td>
<td align="left">指定服务器端口</td>
<td align="left">6379</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">-s</td>
<td align="left">指定服务器 socket</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">-c</td>
<td align="left">指定并发连接数</td>
<td align="left">50</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">-n</td>
<td align="left">指定请求数</td>
<td align="left">10000</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">-d</td>
<td align="left">以字节的形式指定 SET&#x2F;GET 值的数据大小</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">-k</td>
<td align="left">1&#x3D;keep alive 0&#x3D;reconnect</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">-r</td>
<td align="left">SET&#x2F;GET&#x2F;INCR 使用随机 key, SADD 使用随机值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">-P</td>
<td align="left">通过管道传输 <numreq> 请求</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">-q</td>
<td align="left">强制退出 redis。仅显示 query&#x2F;sec 值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">–csv</td>
<td align="left">以 CSV 格式输出</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">-l（L 的小写字母）</td>
<td align="left">生成循环，永久执行测试</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">-t</td>
<td align="left">仅运行以逗号分隔的测试命令列表。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">-I（i 的大写字母）</td>
<td align="left">Idle 模式。仅打开 N 个 idle 连接并等待。</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><h3 id="分区特点"><a href="#分区特点" class="headerlink" title="分区特点"></a>分区特点</h3><p>分区是分割数据到多个redis实例的处理过程，每个实例只保存key的一个子集。</p>
<p>优点：</p>
<ul>
<li>利用多台计算机内存的和值，可以构造更大的数据库</li>
<li>通过多核和多台计算机，可以扩展计算能力</li>
<li>通过多台计算机和网络适配器，允许扩展网络带宽</li>
</ul>
<p>缺点：</p>
<ul>
<li>涉及多个key的操作不被支持</li>
<li>涉及多个key的事务不能使用</li>
<li>使用分区时，数据处理较复杂</li>
<li>增加与删除容量也比较复杂</li>
</ul>
<h3 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h3><p>假设有<code>n</code>个redis实例</p>
<h4 id="范围分区"><a href="#范围分区" class="headerlink" title="范围分区"></a>范围分区</h4><p>即映射一定范围的对象到特定的redis实例</p>
<p>不足：需要有区间范围到实例的映射表，该表需要被管理，同时需各种对象的映射表，通常不算好。</p>
<h4 id="哈希分区"><a href="#哈希分区" class="headerlink" title="哈希分区"></a>哈希分区</h4><ol>
<li>使用哈希函数转换key为一个数字</li>
<li>对该整数取模，将其转化为<code>0-(n-1)</code>之间的数字，将该整数映射到<code>n</code>个redis实例中的其中一个</li>
</ol>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>redis不同于memcached的最重要的一点就是其支持持久化。有以下三种持久化方式：</p>
<ul>
<li>快照(snapshotting, RDB)</li>
<li>只追加文件(append-only files, AOF)</li>
<li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li>
</ul>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>通过创建快照（全量快照）来获得存储在内存里的数据在某个时间点上的副本。</p>
<p>创建快照后，可以对快照进行备份，可以将其赋值到其他服务器从而创建具有相同数的服务器副本（Redis 主从结构，主要用来提高 Redis 性能）。还可以将快照留在原地以便重启服务器时使用。</p>
<p>快照是redis默认采用的持久化方式。在redis.conf中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><br></pre></td></tr></table></figure>

<p><strong>RDB创建快照是会阻塞主线程吗？</strong></p>
<p>提供了两个命令来生成快照文件：</p>
<ul>
<li><code>SAVE</code>：同步保存，会阻塞redis主线程</li>
<li><code>BGSAVE</code>：fork出子进程，不阻塞主线程，默认选项。</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>redis默认不开启AOF（6.0后默认开启），未开启时可以通过<code>appendonly yes</code>开启</p>
<p>总而体验，AOF的工作流程如下：</p>
<ol>
<li><p><strong>命令追加append</strong>：所有<code>写命令</code>都会被追加到AOF缓冲区中</p>
</li>
<li><p><strong>文件写入write</strong>：将AOF缓冲区数据写入到AOF文件中，系统会调用<code>write</code>函数。<code>write</code>将数据写入到了系统内核缓冲区之后直接返回了（延迟写，即不会立马同步到硬盘）。注意！！！此时并没有同步到磁盘。</p>
</li>
<li><p><strong>文件同步fsync</strong>：根据持久化方式（<code>fsync</code>策略）向硬盘做同步操作，系统会调用<code>fsync</code>函数。<code>fsync</code>针对单个文件操作，对其进行强制硬盘同步。<code>fsync</code>将阻塞直到写入硬盘完成后返回，保证了数据持久化。</p>
</li>
<li><p><strong>文件重写rewrite</strong>：随着AOF文件越来越大，需对AOF文件进行重写，达到压缩的目的</p>
<blockquote>
<p>重写的新文件与原AOF文件所保存的数据库状态一样，但是体积更小。</p>
<p>该功能是通过读取数据库中的键值对来实现的（即读取最新的键值对），程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</p>
<p>大量写入操作，防止对正常处理命令造成影响，将其放入子进程中执行</p>
<p>重写期间，Redis还会维护一个<strong>AOF重写缓冲区</strong>，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p>
<p><strong>重写开启</strong></p>
<ol>
<li>调用<code>BGREWRITEAOF</code>手动执行</li>
<li>设置配置项，让程序自动决定触发时机：</li>
</ol>
<ul>
<li><code>auto-aof-rewrite-min-size</code>：如果 AOF 文件大小小于该值，则不会触发 AOF 重写。默认值为 64 MB;</li>
<li><code>auto-aof-rewrite-percentage</code>：执行 AOF 重写时，当前 AOF 大小（aof_current_size）和上一次重写时 AOF 大小（aof_base_size）的比值。如果当前 AOF 文件大小增加了这个百分比值，将触发 AOF 重写。将此值设置为 0 将禁用自动 AOF 重写。默认值为 100。</li>
</ul>
</blockquote>
</li>
<li><p><strong>重启加载load</strong>：redis重启时，可以加载AOF文件进行数据恢复</p>
</li>
</ol>
<p>只有同步到硬盘才算持久化保存了，否则依然有数据丢失的风险。如系统内核缓存区的数据还未同步，磁盘机器就宕机了。</p>
<p>AOF文件的保存文件通RDB文件位置，都是通过<code>dir</code>设置的，默认文件名为<code>appendonly.aof</code></p>
<h4 id="AOF为什么在执行完命令之后记录日志"><a href="#AOF为什么在执行完命令之后记录日志" class="headerlink" title="AOF为什么在执行完命令之后记录日志"></a>AOF为什么在执行完命令之后记录日志</h4><p>关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。即先执行写命令，再记录到AOF文件中</p>
<p>why?</p>
<ul>
<li>避免额外的检查开销，AOF记录日志不会对命令进行语法检查</li>
<li>命令执行完后再记录，不会阻塞当前命令的执行</li>
</ul>
<p>问题：</p>
<ul>
<li>刚执行完命令redis就宕机，会导致数据丢失</li>
<li>可能阻塞后续其他命令执行（AOF记录日志是在redis主线程中进行）</li>
</ul>
<h4 id="持久化方式（fsync策略）"><a href="#持久化方式（fsync策略）" class="headerlink" title="持久化方式（fsync策略）"></a>持久化方式（fsync策略）</h4><ol>
<li><code>appendfsync always</code>：主线程调用 <code>write</code> 执行写操作后，后台线程（ <code>aof_fsync</code> 线程）立即会调用 <code>fsync</code> 函数同步 AOF 文件（刷盘），<code>fsync</code> 完成后线程返回，这样会严重降低 Redis 的性能（<code>write</code> + <code>fsync</code>）。</li>
<li><code>appendfsync everysec</code>：主线程调用 <code>write</code> 执行写操作后立即返回，由后台线程（ <code>aof_fsync</code> 线程）每秒钟调用 <code>fsync</code> 函数（系统调用）同步一次 AOF 文件（<code>write</code>+<code>fsync</code>，<code>fsync</code>间隔为 1 秒）</li>
<li><code>appendfsync no</code>：主线程调用 <code>write</code> 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（<code>write</code>但不<code>fsync</code>，<code>fsync</code> 的时机由操作系统决定）。</li>
</ol>
<p>可见，其差别主要在于<code>fsync</code>同步AOF文件的时机（刷盘）</p>
<h4 id="AOF校验机制"><a href="#AOF校验机制" class="headerlink" title="AOF校验机制"></a>AOF校验机制</h4><p>AOF 校验机制是 Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。</p>
<p>这个机制的原理是通过使用一种叫做 <strong>校验和（checksum）</strong> 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 CRC64 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。</p>
<p>因此，Redis 在启动时会比较计算出的校验和与文件末尾保存的校验和（计算的时候会把最后一行保存校验和的内容给忽略掉），从而判断 AOF 文件是否完整。</p>
<p>如果发现文件有问题，Redis 就会拒绝启动并提供相应的错误信息。AOF 校验机制十分简单有效，可以提高 Redis 数据的可靠性。</p>
<p>类似地，RDB 文件也有类似的校验机制来保证 RDB 文件的正确性。</p>
<h3 id="RDB-和-AOF-的混合持久化-Redis-4-0-新增"><a href="#RDB-和-AOF-的混合持久化-Redis-4-0-新增" class="headerlink" title="RDB 和 AOF 的混合持久化(Redis 4.0 新增)"></a>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</h3><p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p>
<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。</p>
<p>优点：可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。</p>
<p>缺点：AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>
<h3 id="RDB-vs-AOF"><a href="#RDB-vs-AOF" class="headerlink" title="RDB vs. AOF"></a>RDB vs. AOF</h3><p><strong>RDB 比 AOF 优秀的地方</strong>：</p>
<ul>
<li>RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会比 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</li>
<li>使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。</li>
</ul>
<p><strong>AOF 比 RDB 优秀的地方</strong>：</p>
<ul>
<li>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比较繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。</li>
<li>RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。</li>
<li>AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行<code>FLUSHALL</code>命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态.</li>
</ul>
<p><strong>综上</strong>：</p>
<ul>
<li>Redis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。</li>
<li>不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。</li>
<li>如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。</li>
</ul>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p><strong>1. 使用批量操作减少网络传输</strong> </p>
<p>一个 Redis 命令的执行可以简化为以下 4 步：</p>
<ol>
<li>发送命令</li>
<li>命令排队</li>
<li>命令执行</li>
<li>返回结果</li>
</ol>
<p>1和4消耗的时间为RTT(往返时间)，即数据在网络上传输的时间</p>
<p>可以使用批量操作减少网络传输次数，进而有效减少网络开销，大幅减少RTT。</p>
<p>此外，发送一次命令的 socket I&#x2F;O 成本也比较高（涉及上下文切换，存在<code>read()</code>和<code>write()</code>系统调用），批量操作还可以减少 socket I&#x2F;O 成本。</p>
<ul>
<li>原生批量操作：如MSET, MGET, HSET, SADD【原子操作】</li>
<li>pipeline：不支持批量操作的命令，可以使用pipeline将一批命令封装成一组，这些命令会被一次性提交到redis服务器，只需一次网络传输。不过，需控制一次批量操作的元素个数，避免实际网络传输的数据量过大【非原子操作】</li>
</ul>
<p>都存在的问题：无法保证所有的 key 都在同一个 hash slot（哈希槽）上</p>
<p><strong>2. 大量key集中过期问题</strong></p>
<p>对过期key，redis采用：定期删除+惰性&#x2F;懒汉式删除</p>
<p>定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢。</p>
<p>解决方法：</p>
<ul>
<li>给key设置随机过期时间</li>
<li>开启lazy-free（惰性删除&#x2F;延迟释放），即让redis采用异步方法延迟释放key使用的内存，该操作交由单独的子线程处理，避免阻塞主线程。</li>
</ul>
<p><strong>3. bigkey(大key)</strong></p>
<p>Bigkey：key对应的value占用的内存较大。</p>
<p>危害：除了会消耗更多的内存空间和带宽外，还会对性能造成较大影响</p>
<p>如何发现bigkey?</p>
<ul>
<li><p>使用redis自带的<code>--bigkeys</code>参数来查找</p>
<blockquote>
<p>会扫描所有key，对性能有一点影响。且只能找出每种数据结构的top 1 bigkey</p>
<p>为降低对redis影响，可以使用<code>-i</code>参数控制扫描频率，单位为s</p>
</blockquote>
</li>
<li><p>借助开源工具分析RDB文件</p>
<blockquote>
<p>如果采用的是RDB持久化</p>
</blockquote>
</li>
<li><p>借助公有云的redis分析服务</p>
</li>
</ul>
<p>如何处理bigkey?</p>
<ul>
<li><p><strong>分割 bigkey</strong>：将一个 bigkey 分割为多个小 key。这种方式需要修改业务层的代码，一般不推荐这样做。</p>
</li>
<li><p><strong>手动清理</strong>：Redis 4.0+ 可以使用 <code>UNLINK</code> 命令来异步删除一个或多个指定的 key。Redis 4.0 以下可以考虑使用 <code>SCAN</code> 命令结合 <code>DEL</code> 命令来分批次删除。</p>
</li>
<li><p><strong>采用合适的数据结构</strong>：比如使用 HyperLogLog 统计页面 UV。</p>
</li>
<li><p><strong>开启 lazy-free（惰性删除&#x2F;延迟释放）</strong> ：lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程.</p>
</li>
</ul>
<p><strong>4. hotkey(热key)</strong></p>
<p>hotkey：一个key的访问次数明显多于其他key</p>
<p>出现原因：某个热点数据访问量暴增</p>
<p><strong>危害</strong></p>
<ul>
<li>处理hotkey会占用大量CPU与带宽，可能影响redis实例对其他请求的处理</li>
<li>访问hotkey的请求超过了redis的处理能力，会造成redis直接宕机，然后大量请求将会落在数据库上，可能导致数据库崩溃</li>
</ul>
<p>故hotkey可能称为系统性能瓶颈点，需对其进行单独优化，保证系统高可用性和稳定性</p>
<p><strong>如何发现hotkey?</strong></p>
<ul>
<li><p>使用redis自带的<code>--hotkeys</code>来查找</p>
<p>该参数能够返回所有 key 的被访问次数。会增加 Redis 实例的 CPU 和内存消耗（全局扫描），因此需要谨慎使用。</p>
<p>使用该方案的前提条件是 Redis Server 的 <code>maxmemory-policy</code> 参数设置为 LFU 算法，不然就会出现如下所示的错误。</p>
<blockquote>
<p>Redis 中有两种 LFU 算法：</p>
<ol>
<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最不经常使用的数据淘汰。</li>
<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。</li>
</ol>
</blockquote>
</li>
<li><p>使用<code>MONITOR</code>命令</p>
<p>可以时查看 Redis 的所有操作，可以用于临时监控 Redis 实例的操作情况，包括读写、删除等操作。</p>
<p>该命令对 Redis 性能的影响比较大，因此禁止长时间开启 <code>MONITOR</code>（生产环境中建议谨慎使用该命令）。</p>
<p>紧急情况下可以在合适实际短暂使用该命令并输出至重定向文件，然后关闭命令、分析文件后找出hotkey</p>
</li>
<li><p>借助开源项目</p>
</li>
<li><p>根据业务情况提前预估</p>
</li>
<li><p>业务代码中记录分析：会增加代码复杂度</p>
</li>
<li><p>借助公有云的redis分析服务</p>
</li>
</ul>
<p><strong>如何解决hotkey?</strong></p>
<p><strong>读写分离</strong>：主节点处理写请求，从节点处理读请求。</p>
<p><strong>使用 Redis Cluster</strong>：将热点数据分散存储在多个 Redis 节点上。</p>
<p><strong>二级缓存</strong>：hotkey 采用二级缓存的方式进行处理，将 hotkey 存放一份到 JVM 本地内存中（可以用 Caffeine）。</p>
<p><strong>5. 慢查询命令</strong></p>
<p>慢查询统计的是<code>命令执行</code>这一步的耗时，慢查询命令即为命令执行时间较长的命令</p>
<p>redis中大部分命令都是$O(1)$的时间复杂度，但也有少部分 $O(n)$的，如：LRANGE, HGETALL, SMEMBERS, SINTER, SUNION, SDIFF</p>
<p>除了这些 $O(n)$时间复杂度的命令可能会导致慢查询之外， 还有一些时间复杂度可能在$ O(N) $以上的命令，如：<code>ZRANGE</code>为$O(log_{2}n+m)$，m为返回元素个数，m很大时，$O(n)$时间复杂度更低</p>
<p><strong>如何找到慢查询命令？</strong></p>
<p>在<code>redis.conf</code>中使用<code>slowlog-log-slower-than</code>参数设置耗时命令的阈值，并使用<code>slowlog-max-len</code>参数设置耗时命令的最大记录条数（也可以通过<code>CONF</code>命令直接设置）</p>
<p>当 Redis 服务器检测到执行时间超过 <code>slowlog-log-slower-than</code>阈值的命令时，就会将该命令记录在慢查询日志(slow log) 中，这点和 MySQL 记录慢查询语句类似。当慢查询日志超过设定的最大记录条数之后，Redis 会把最早的执行命令依次舍弃。</p>
<p>获取慢查询日志：<code>SLOWLOG GET</code>，默认返回最近 10 条的的慢查询命令，也可以指定返回的慢查询命令的数量 <code>SLOWLOG GET N</code>。</p>
<p><strong>6. redis内存碎片</strong></p>
<p><strong>为什么会有内存碎片？</strong></p>
<ol>
<li>存储数据时向系统申请的内存空间大于数据实际需要的存储空间</li>
<li>频繁修改redis中的数据时产生</li>
</ol>
<p>查看内存碎片：<code>info memory</code></p>
<p><strong>如何清理内存碎片？</strong></p>
<p>Redis4.0-RC3 版本以后自带了内存整理，可以避免内存碎片率过大的问题。</p>
<p>直接通过 <code>config set</code> 命令将 <code>activedefrag</code> 配置项设置为 <code>yes</code> 即可。</p>
<h2 id="生产问题"><a href="#生产问题" class="headerlink" title="生产问题"></a>生产问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>定义：大量请求的key是不合理的，其不存在于缓存中，也不存在于数据库中，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是<strong>缓存穿透</strong>的问题。</p>
<p>发生情况：</p>
<ul>
<li>业务误操作</li>
<li>恶意攻击</li>
</ul>
<p>应对方案：</p>
<p><strong>1. 非法请求的限制</strong></p>
<p>做好参数校验，判断出恶意请求就直接返回错误</p>
<p><strong>2. 缓存空值或默认值</strong></p>
<p>发现存在缓存穿透的现象，可以针对查询数据，在缓存中设置空值或无效值，后续查询可以直接返回该无效值。</p>
<p>适用于key变化不频繁的场景，存在大量无效key时依然不能解决。</p>
<p><strong>3. 使用布隆过滤器快速判断数据是否存在，避免查询数据库判断其是否存在</strong></p>
<p>把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<p>即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的。</p>
<p><strong>注</strong>：布隆过滤器可能会存在误判的情况。总结来说就是：<strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在</strong>。</p>
<p>将一个元素加入布隆过滤器，会进行：</p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算得到哈希值（几个哈希函数得几个哈希值）</li>
<li>根据得到的哈希值，在位数组中将其对应下标置1</li>
</ol>
<p>判断元素是否存在于布隆过滤器：</p>
<ol>
<li>对元素再次进行相同的哈希计算【判断时可能存在哈希冲突，即不同元素的哈希值相同】</li>
<li>得到值后判断位数组中的每个元素是否都为1，都为1时，说明在布隆过滤器中，否则，则说明不在布隆过滤器中</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>定义：请求的key对应的是热点数据，该数据存在于数据库中，但是不存在于缓存中（通常由于已过期），则会导致大量请求直接发送给数据库，造成数据库宕机。</p>
<p>解决办法：</p>
<ul>
<li>设置热点数据永不过期或过期时间较长</li>
<li>针对热点数据提前预热，将其存入缓存中并设置合理的过期时间</li>
<li>请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力</li>
</ul>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>定义：缓存在同一时间大面积失效，导致大量请求都直接落在数据库上，对数据库造成了巨大压力，导致其宕机。</p>
<p>缓存服务宕机也会导致请求直接落在数据库上，造成缓存雪崩。</p>
<p><strong>解决办法</strong>：</p>
<ol>
<li>针对redis服务不可用：<ul>
<li>采用redis集群，避免单机出问题导致整个缓存服务都无法使用</li>
<li>限流，避免同时处理大量请求</li>
</ul>
</li>
<li>针对缓存失效问题：<ul>
<li>设置不同的失效时间，如随机设置缓存的失效时间</li>
<li>缓存永不失效（实用性差）</li>
<li>设置二级缓存</li>
</ul>
</li>
</ol>
<p>缓存击穿可以看作缓存雪崩的一种</p>
<h2 id="如何保证缓存和数据库数据一致性"><a href="#如何保证缓存和数据库数据一致性" class="headerlink" title="如何保证缓存和数据库数据一致性"></a>如何保证缓存和数据库数据一致性</h2><p>数据更新：无论是先更新数据库还是先更新缓存，都存在并发问题。当两个请求并发更新同一条数据时，可能出现缓存中和数据中的数据不一致的情况。</p>
<p><strong>Cache Aside Pattern</strong>旁路缓存策略：先更新数据库，再删除缓存</p>
<p>其中又分为两个策略：读策略和写策略</p>
<p>写策略：</p>
<ol>
<li>更新数据库中的数据</li>
<li>删除缓存中的数据</li>
</ol>
<p>读策略：</p>
<ol>
<li>读取的数据命中缓存则直接返回</li>
<li>未命中缓存，从数据库中读取数据，将数据写入缓存并返回</li>
</ol>
<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p>
<ol>
<li><strong>缓存失效时间变短（不推荐，治标不治本）</strong>：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li><strong>增加 cache 更新重试机制（常用）</strong>：如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li>
</ol>

    </div>

    
    
    

    
      <div>
       <div>
    
        <div style="text-align:center;color: #3F92A4;font-size:15px;">-------------END OF TEXT <i class="fa fa-tree"></i> Thanks for reading(●'◡'●)-------------</div>
    
</div>
      </div>
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Mooyi
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://mooyi646.github.io/post/bae4ff13.html" title="Redis">https://mooyi646.github.io/post/bae4ff13.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Redis/" rel="tag"># Redis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/post/f8355b15.html" rel="prev" title="leetcode记录">
      <i class="fa fa-chevron-left"></i> leetcode记录
    </a></div>
      <div class="post-nav-item">
    <a href="/post/cbb39f4b.html" rel="next" title="Helm">
      Helm <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis"><span class="nav-number">1.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#string"><span class="nav-number">1.1.1.</span> <span class="nav-text">string</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">内部实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.1.1.3.1.</span> <span class="nav-text">缓存对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E8%A7%84%E8%AE%A1%E6%95%B0"><span class="nav-number">1.1.1.3.2.</span> <span class="nav-text">常规计数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">1.1.1.3.3.</span> <span class="nav-text">分布式锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B1%E4%BA%ABsession%E4%BF%A1%E6%81%AF"><span class="nav-number">1.1.1.3.4.</span> <span class="nav-text">共享session信息</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hash"><span class="nav-number">1.1.2.</span> <span class="nav-text">hash</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-1"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">内部实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.1.2.3.1.</span> <span class="nav-text">存储对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B4%AD%E7%89%A9%E8%BD%A6"><span class="nav-number">1.1.2.3.2.</span> <span class="nav-text">购物车</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list"><span class="nav-number">1.1.3.</span> <span class="nav-text">list</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-2"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-2"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">内部实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">1.1.3.3.1.</span> <span class="nav-text">消息队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set"><span class="nav-number">1.1.4.</span> <span class="nav-text">set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-3"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">运算操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-3"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">内部实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%82%B9%E8%B5%9E"><span class="nav-number">1.1.4.4.1.</span> <span class="nav-text">点赞</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B1%E5%90%8C%E5%85%B3%E6%B3%A8"><span class="nav-number">1.1.4.4.2.</span> <span class="nav-text">共同关注</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8A%BD%E5%A5%96%E6%B4%BB%E5%8A%A8"><span class="nav-number">1.1.4.4.3.</span> <span class="nav-text">抽奖活动</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zset"><span class="nav-number">1.1.5.</span> <span class="nav-text">zset</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-4"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E6%93%8D%E4%BD%9C-1"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">运算操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-4"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">内部实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%92%E8%A1%8C%E6%A6%9C"><span class="nav-number">1.1.5.4.1.</span> <span class="nav-text">排行榜</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.</span> <span class="nav-text">特殊数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BitMap"><span class="nav-number">1.2.1.</span> <span class="nav-text">BitMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-5"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E6%93%8D%E4%BD%9C-2"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">运算操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-5"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">内部实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-5"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AD%BE%E5%88%B0%E7%BB%9F%E8%AE%A1"><span class="nav-number">1.2.1.4.1.</span> <span class="nav-text">签到统计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81"><span class="nav-number">1.2.1.4.2.</span> <span class="nav-text">判断用户登录状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E7%AD%BE%E5%88%B0%E7%94%A8%E6%88%B7%E6%80%BB%E6%95%B0"><span class="nav-number">1.2.1.4.3.</span> <span class="nav-text">连续签到用户总数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HyperLogLog"><span class="nav-number">1.2.2.</span> <span class="nav-text">HyperLogLog</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-6"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">常用命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GEO"><span class="nav-number">1.2.3.</span> <span class="nav-text">GEO</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-7"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-6"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">内部实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.3.2.1.</span> <span class="nav-text">使用场景</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="nav-number">1.3.</span> <span class="nav-text">发布订阅</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream"><span class="nav-number">1.4.</span> <span class="nav-text">Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%EF%BC%9A"><span class="nav-number">1.4.1.</span> <span class="nav-text">消息队列相关命令：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E7%BB%84%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-number">1.4.2.</span> <span class="nav-text">消费组相关命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.3.</span> <span class="nav-text">问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.5.</span> <span class="nav-text">事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC"><span class="nav-number">1.6.</span> <span class="nav-text">脚本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="nav-number">1.7.</span> <span class="nav-text">数据备份与恢复</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="nav-number">1.8.</span> <span class="nav-text">性能测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%8C%BA"><span class="nav-number">1.9.</span> <span class="nav-text">分区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E7%89%B9%E7%82%B9"><span class="nav-number">1.9.1.</span> <span class="nav-text">分区特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.9.2.</span> <span class="nav-text">分区类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4%E5%88%86%E5%8C%BA"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">范围分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E5%88%86%E5%8C%BA"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">哈希分区</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">1.10.</span> <span class="nav-text">Redis持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB"><span class="nav-number">1.10.1.</span> <span class="nav-text">RDB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF"><span class="nav-number">1.10.2.</span> <span class="nav-text">AOF</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.10.2.1.</span> <span class="nav-text">工作流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E6%89%A7%E8%A1%8C%E5%AE%8C%E5%91%BD%E4%BB%A4%E4%B9%8B%E5%90%8E%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97"><span class="nav-number">1.10.2.2.</span> <span class="nav-text">AOF为什么在执行完命令之后记录日志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%88fsync%E7%AD%96%E7%95%A5%EF%BC%89"><span class="nav-number">1.10.2.3.</span> <span class="nav-text">持久化方式（fsync策略）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF%E6%A0%A1%E9%AA%8C%E6%9C%BA%E5%88%B6"><span class="nav-number">1.10.2.4.</span> <span class="nav-text">AOF校验机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB-%E5%92%8C-AOF-%E7%9A%84%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96-Redis-4-0-%E6%96%B0%E5%A2%9E"><span class="nav-number">1.10.3.</span> <span class="nav-text">RDB 和 AOF 的混合持久化(Redis 4.0 新增)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB-vs-AOF"><span class="nav-number">1.10.4.</span> <span class="nav-text">RDB vs. AOF</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">1.11.</span> <span class="nav-text">性能优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98"><span class="nav-number">1.12.</span> <span class="nav-text">生产问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">1.12.1.</span> <span class="nav-text">缓存穿透</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-number">1.12.2.</span> <span class="nav-text">缓存击穿</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">1.12.3.</span> <span class="nav-text">缓存雪崩</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">1.13.</span> <span class="nav-text">如何保证缓存和数据库数据一致性</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mooyi"
      src="https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281528071.png">
  <p class="site-author-name" itemprop="name">Mooyi</p>
  <div class="site-description" itemprop="description">Live with fun</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Mooyi646" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Mooyi646" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/mooyixh@gmail.com" title="E-Mail → mooyixh@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/LuoMooyi" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;LuoMooyi" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>FB Page</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/m00y1h" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;m00y1h" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="Link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://google.com/" title="http:&#x2F;&#x2F;google.com" rel="noopener" target="_blank">Google</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://bing.com/" title="http:&#x2F;&#x2F;bing.com" rel="noopener" target="_blank">Bing</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-07 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mooyi</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">152k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">2:19</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://mooyi.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://mooyi646.github.io/post/bae4ff13.html";
    this.page.identifier = "post/bae4ff13.html";
    this.page.title = "Redis";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://mooyi.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
