[{"title":"容器与集合","url":"/post/5d4053e7.html","content":"\n\n\n# 容器与集合\n\n## Collection体系\n\n![image-20231211195144263](https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202312111951493.png)\n\n### 常见方法\n\n````java\n// 增加元素\nboolean add(Object obj)\nboolean addAll(Collection c)\n\n// 删除元素\nvoid clear()\nboolean remove(Object obj)\n\nboolean contains(Object obj)\n\nboolean equals(Object obj)\n\nboolean isEmpty()\n\nint size()\n\nObject[] toArray()\n    \n//排序，需Object对象实现Comparable接口\nCollection sort(Object c)\n//使用方式\nCollections.sort(Collection c)\n````\n\n**注**：\n\n* `length`属性：针对数组，即数组长度\n* `length()`：针对字符串，即字符串长度\n* `size()`：针对泛型集合，即泛型元素个数\n\n\n\n### 集合遍历\n\n#### 1. for-each\n\n````java\nfor(Object obj : Collection c){\n    //action\n}\n````\n\n\n\n#### 2. Iterator\n\n````java\n/* 常用方法\nboolean hasNext()\nE next()\nvoid remove()\n*/\nCollection collection;\nIterator<E> it = collection.iterator();\nwhile(it.hasNext()){\n    E obj = it.next();\n    //可以使用it.remove()删除当前元素\n    //不能使用collection.remove()删除，会报并发修改异常\n}\n````\n\n\n\n\n\n\n\n## List\n\n ### List接口\n\n#### 创建对象\n\n````java\nList<E> list1 =  new ArrayList<>();\nList<E> list2 =  new LinkedList<>();\n````\n\n\n\n#### 常用方法\n\n````java\n//添加元素，会对基本类型自动装箱\nlist.add();\n\n//删除元素，可以使用索引删除，也可以删除某个元素（多次出现时删除第一个）\nlist.remove(0);//返回删除的元素\nlist.remove(\"value\")；//返回true/fasle\n//注：当删除数字与索引冲突时，将数字变为引用类型\n    \n//访问元素，使用索引访问\nlist.get(0);\n\n//修改元素，指定索引与修改后的值\nlist.set(2,\"value\")\n    \n//获取索引/位置\nlist.indexOf(\"value\");\n\n//获取子集合，左闭右开\nlist.subList(1,3);//获取的是索引为1，2\n````\n\n\n\n#### 遍历\n\n除集合的`for-each`，`iterator`外还可使用：\n\n1. 直接使用`for循环`遍历\n\n2. 使用`列表迭代器`\n\n   ````java\n   ListIterator li = list.ListIterator();\n   \n   //从前往后遍历\n   while(li.hasNext()){\n       li.nextIndex();\n       li.next();\n   }\n   \n   //从后往前遍历\n   while(li.hasPrevious()){\n       li.previousIndex();\n       li.previous();\n   }\n   ````\n\n   \n\n\n\n### List实现类对比(ArrayList, LinkdedList, Vector)\n\n|                  | ArrayList                                                 | LinkedList                                                   | Vector         |\n| ---------------- | --------------------------------------------------------- | ------------------------------------------------------------ | -------------- |\n| 实现方式         | Object数组                                                | 双向链表                                                     | Object数组     |\n| 是否需要连续空间 | 是                                                        | 否                                                           | 是             |\n| 速度             | 查询快（$O(1)$）<br />增删慢（$O(n)$,尾插不扩容为$O(1)$） | 查询慢（$O(n)$）<br />增删快（头尾插$O(1)$,指定位置插$O(n)$） | 查询快、增删慢 |\n| 是否线程安全     | 否                                                        | 否                                                           | 是             |\n| 是否支持随机访问 | 是                                                        | 否（故不能实现RandomAccess接口）                             | 是             |\n\n**RandomAccess接口**\n\n源码：\n\n````java\npublic interface RandomAccess {\n}\n````\n\n什么都没有定义，相当于只是一个**标识**实现此接口的类具有随机访问的功能。\n\n**注：ArrayList不是实现了RandomAccess接口才有的随机访问能力，而是底层数据结构使其天然有随机访问能力，RandomAccess只是表明其有此能力，只有标识的功能。**\n\n\n\n### ArrayList源码分析\n\n底层数据结构：数组队列，即相当于动态数组。\n\n````java\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable{\n\n  }\n````\n\n实现的接口：\n\n* List：表明其是一个列表，支持List的基本操作\n\n* RandomAccess：标识其支持快速随机访问\n\n* Cloneable：表明其具有拷贝能力，可以进行深拷贝或浅拷贝\n\n  > * 浅拷贝：新创建一个对象，该对象有着原始对象属性值的一份精确拷贝。即原始对象属性为基本类型，则拷贝基本属性的值，若其为引用类型，拷贝其内存空间地址（即不会新创建这个引用类型）\n  > * 深拷贝：将对象从内存中完整拷贝出来，即会在堆中创建新对象，若原始对象属性为引用类型，则会重新创建这个引用类型。（即不与原始对象共享内存）\n\n* Serializable：表明可以进行序列化操作。即将对象转化为字节流进行持久化存储或网络传输。\n\n\n\n源码分析\n\n````java\nDEFAULT_CAPACITY = 10; //默认容量\n//注意：未指定初始容量时，如果没有向集合中添加任何元素时，容量0，添加一个后，容量为10\n//每次扩容是原来的1.5倍\nelementData存放元素的数组\nsize 实际元素个数\n````\n\n\n\n#### 扩容机制\n\n**ArrayList的构造函数（共三种）**\n\n````java\n   /**\n     * 默认初始容量大小\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n\n    /**\n     * 空数组（用于空实例）。用于指定了容量为0的空数组\n     */\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n\n     //用于默认大小空实例的共享空数组实例。\n     //我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /**\n     * 1. 默认构造函数，使用初始容量10构造一个空列表(无参数构造)\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n    /**\n     * 2. 带初始容量参数的构造函数。（用户自己指定容量）\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {//初始容量大于0\n            //创建initialCapacity大小的数组\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {//初始容量等于0\n            //创建空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {//初始容量小于0，抛出异常\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n\n   /**\n    * 3. 构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回\n    *    如果指定的集合为null，throws NullPointerException。\n    */\n     public ArrayList(Collection<? extends E> c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n````\n\n无参构造创建ArrayList时，初始化赋值的为一个空数组。真正添加元素时才会分配容量，即添加第一个元素时，容量初始化为10.\n\n\n\n以无参构造函数分析扩容机制：\n\n`add`方法：\n\n````java\n    /**\n     * 将指定的元素追加到此列表的末尾。\n     */\n    public boolean add(E e) {\n   //添加元素之前，先调用ensureCapacityInternal方法\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //这里看到ArrayList添加元素的实质就相当于为数组赋值\n        elementData[size++] = e;\n        return true;\n    }\n````\n\n可以看到首先调用了`ensureCapacityInternal(size + 1)`\n\n````java\n   //得到最小扩容量\n    private void ensureCapacityInternal(int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n              // 获取默认的容量和传入参数的较大值\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n\n        ensureExplicitCapacity(minCapacity);\n    }\n````\n\n当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。\n\n然后其又调用了`ensureExplicitCapacity(minCapacity)`\n\n````java\n  //判断是否需要扩容\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // overflow-conscious code\n        if (minCapacity - elementData.length > 0)\n            //调用grow方法进行扩容，调用此方法代表已经开始扩容了\n            grow(minCapacity);\n    }\n````\n\n即为：\n\n* add第1个元素时，`elementData.length=0`执行`ensureCapacityInternal`方法，`minCapacity`变为`10`。此时`minCapacity - elementData.length > 0`成立，调用`grow(minCapacity)`\n* add第2个元素时，`elementData.length=10`，`minCapability=2`，所以`minCapacity - elementData.length > 0`不成立，不会调用`grow(minCapacity);`\n* 直到add第11个元素，此时`elementData.length=10`，`minCapability=11`，调用`grow(minCapacity)`进行**扩容**\n\n`grow()`\n\n````java\n    /**\n     * 要分配的最大数组大小\n     */\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    /**\n     * ArrayList扩容的核心方法。\n     */\n    private void grow(int minCapacity) {\n        // oldCapacity为旧容量，newCapacity为新容量\n        int oldCapacity = elementData.length;\n        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\n        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍(偶数为1.5倍，奇数为1.5倍左右)\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n       // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，\n       //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n\n````\n\n如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE\n\n````java\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        //对minCapacity和MAX_ARRAY_SIZE进行比较\n        //若minCapacity大，将Integer.MAX_VALUE作为新数组的大小\n        //若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小\n        //MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n````\n\n\n\n#### System.arraycopy() vs.  Arrays.copyOf()\n\n`System.arraycopy()`\n\n````java\n    // arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义\n    /**\n    *   复制数组\n    * @param src 源数组\n    * @param srcPos 源数组中的起始位置\n    * @param dest 目标数组\n    * @param destPos 目标数组中的起始位置\n    * @param length 要复制的数组元素的数量\n    */\n    public static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n````\n\n`Arrays.copyOf()`\n\n```java\npublic static int[] copyOf(int[] original, int newLength) {\n\t// 申请一个新的数组\n    int[] copy = new int[newLength];\n// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组\n    System.arraycopy(original, 0, copy, 0,\n                     Math.min(original.length, newLength));\n    return copy;\n}\n```\n\n* 联系：Arrays.copyOf()内部调用了System.arraycopy()\n\n* 区别：arraycopy()需要目标数组，可以选择拷贝的起点、放入目标数组的起点；\n\n              copyOf()是在内部新建一个数组然后返回。\n\n\n\n\n\n## Set\n\n特点：\n\n* 无序：不等于随机性，无序指存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定。\n* 无下标\n* 不可重复性：元素按`equals()`判断时，返回`false`，需同时重写`equal()`和`hashCode()`方法。\n\n方法：全部继承自Collection方法\n\n\n\n### Comparable vs. Comparator\n\n|                | Comparable                                                   | Comparator                                                   |\n| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 作用           | 排序接口，相当于内部比较器                                   | 比较接口，相当于外部比较器                                   |\n| 所来自的包     | java.lang                                                    | java.util                                                    |\n| 用于排序的方法 | compareTo(Object obj)                                        | compare(Object obj1, Object obj2)                            |\n| 排序规则       | 正序：当前对象this减去传入的比较对象obj的值<br />倒序：比较对象obj减去当前对象this的值 | 正序：obj1减去obj2的值<br />倒序：obj2减去obj1的值           |\n| 实现           | 需排序的类实现接口后重写`compareTo()`                        | 新建一个类ObjComparator实现该接口，即构造一个“比较器”（也可以直接在`sort`方法中`new Comparator<Object>`然后重写方法[使用匿名内部类]） |\n| 支持           | Collections.sort()<br />Arrays.sort()                        | Collections.sort(Object obj, new ObjComparator)<br />Arrays.sort(Object obj, new ObjComparator()) |\n| 优缺点         | 简单，但是需修改类内部源代码                                 | 不用修改源代码，在实现的比较器中传入需比较对象即可。可以实现可复用的通用逻辑。 |\n\n\n\n### HashSet、LinkedHashSet、TreeSet比较\n\n|              | HashSet                      | LinkedHashSet            | TreeSet                  |\n| ------------ | ---------------------------- | ------------------------ | ------------------------ |\n| 底层数据结构 | 哈希表（基于HashMap实现）    | 哈希表+链表              | 红黑树                   |\n| 应用场景     | 不需要保证元素插入和取出顺序 | 保证插入取出顺序满足FIFO | 支持对元素自定义排序规则 |\n| 是否线程安全 | 否                           | 否                       | 否                       |\n\n**HashSet存储过程**：\n\n1. 根据`hashCode()`计算保存的位置，如果位置为空，直接保存，不为空进入下一步\n   * 利用质数`31`减少散列冲突\n     * 31提高执行效率 `31 * i = (i << 5) - i` 转为移位操作【可以被JVM优化】\n2. 执行`equals()`方法，为`true`则认为重复，拒绝存入，否则形成链表\n\n \n\n## Map\n\n特点：\n\n* 存储任意键值对（`key-value`）\n* `key`：无序、无下标、唯一\n* `value`：无序、无下标，可重复\n\n\n\n常用方法：\n\n````java\n//存储对象\nObject put(Object key, Object value)\n\n//根据key获取value\nObject get(Object Key);\n\n//根据key删除key-value(若存在)\nObject remove(Object key);\n    \n//获取所有key\nSet keySet();\n\n//获取所有映射关系,Set实例化为Set<Map.Entry<String, String>>，然后可以调用每个entry对象的getKey和getValue获取键值对\nSet entrySet();\n````\n\n\n\n### HashMap\n\n可以存储`null`的`key`和`value`，但是`key`最多有一个为`null`.\n\n\n\n#### JDK 1.8之前底层数据结构分析\n\n此时底层数据结构为：**数组和链表**结合使用，即链表散列\n\n数据存储流程：\n\n1. HashMap通过`key`的`hashCode`经过**扰动函数**处理后得到`hash值`\n\n2. 然后通过`(n - 1) & hash`判断当前元素存放的位置（n为数组长度）\n\n   >`(n - 1) & hash`即为`hash % (n)`（当n为$2^x$时）\n\n3. 若当前位置存在元素，则判断该元素与要存入元素的`hash值`以及`key`是否相同\n\n4. 相同直接覆盖；不同则通过**拉链法**解决冲突\n\n\n\n**拉链法**\n\n数组与链表结合，即创建一个链表数组。遇到哈希冲突时，将冲突值加入链表即可。\n\n![image-20231211195341444](https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202312111953674.png)\n\n#### JDK1.8之后底层数据结构分析\n\n在解决哈希冲突时有了较大变化\n\n在拉链法的基础上：\n\n1. 当链表长度大于阈值（默认为`8`），会首先调用`treeifyBin()`决定是否转换为红黑树\n\n2. 当hashMap`数组长度>=64`时，转换为红黑树以减少搜索时间\n\n   > 红黑树节点数小于6时又会调整为链表\n\n3. 数组长度未达到`64`时，执行`resize()`方法对数组扩容。\n\n![image-20231211195531634](https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202312111955729.png)\n\n\n\n#### 源码分析\n\n##### 属性列表\n\n````java\npublic class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable {\n    // 序列号\n    private static final long serialVersionUID = 362498820763181265L;\n    // 默认的初始容量是16\n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;\n    // 最大容量\n    static final int MAXIMUM_CAPACITY = 1 << 30;\n    // 默认的负载因子\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n    // 当桶(bucket)上的结点数大于等于这个值时会转成红黑树\n    static final int TREEIFY_THRESHOLD = 8;\n    // 当桶(bucket)上的结点数小于等于这个值时树转链表\n    static final int UNTREEIFY_THRESHOLD = 6;\n    // 桶中结构转化为红黑树对应的table的最小容量\n    static final int MIN_TREEIFY_CAPACITY = 64;\n    // 存储元素的数组，总是2的幂次倍\n    transient Node<k,v>[] table;\n    // 存放具体元素的集\n    transient Set<map.entry<k,v>> entrySet;\n    // 存放元素的个数，注意这个不等于数组的长度。\n    transient int size;\n    // 每次扩容和更改map结构的计数器\n    transient int modCount;\n    // 阈值(容量*负载因子) 当实际大小超过阈值时，会进行扩容\n    int threshold;\n    // 负载因子\n    final float loadFactor;\n}\n````\n\n* `loadFactor`负载因子\n\n  控制数组存放数据的疏密程度。\n\n  * 越趋近于`1`，数组中存放的数据(entry)越多，也就越密，也就是会让链表长度增加（即扩容在满了才会发生）；\n\n  * 越趋近于`0`，数组中存放的数据越少，也就越稀疏。\n\n  大小控制：loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为` 0.75f `是官方给出的一个比较好的临界值。\n\n  * **why 0.75**\n\n    $阈值(threshold) = 负载因子(loadFactor) * 容量(capacity)$\n\n    > 元素个数超过threshold就会进行扩容\n\n    由hashMap的机制，容量一直为2的幂。所以为了保证$负载因子(loadFactor) * 容量(capacity)$的结果为整数，loadFactor为0.75比较合理，因为其与2的幂的乘积都为整数。\n\n\n\n##### 构造方法\n\n总共有四个构造方法：\n\n```java\n// 1. 默认构造函数。\npublic HashMap() {\n    this.loadFactor = DEFAULT_LOAD_FACTOR; // all   other fields defaulted\n }\n\n // 2. 包含另一个“Map”的构造函数\n public HashMap(Map<? extends K, ? extends V> m) {\n     this.loadFactor = DEFAULT_LOAD_FACTOR;\n     putMapEntries(m, false);//下面会分析到这个方法\n }\n\n // 3. 指定“容量大小”的构造函数\n public HashMap(int initialCapacity) {\n     this(initialCapacity, DEFAULT_LOAD_FACTOR);\n }\n\n // 4. 指定“容量大小”和“负载因子”的构造函数\n public HashMap(int initialCapacity, float loadFactor) {\n     if (initialCapacity < 0)\n         throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity);\n     if (initialCapacity > MAXIMUM_CAPACITY)\n         initialCapacity = MAXIMUM_CAPACITY;\n     if (loadFactor <= 0 || Float.isNaN(loadFactor))\n         throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor);\n     this.loadFactor = loadFactor;\n     // 初始容量暂时存放到 threshold ，在resize中再赋值给 newCap 进行table初始化\n     this.threshold = tableSizeFor(initialCapacity);\n }\n```\n\n以上4个构造方法中，都初始化了`loadFactor`。\n\n由于HashMap中无capacity字段，所以即使指定了初始容量大小`initialCapacity`，其也只是通过`tableSizeFor`将其扩容到与其**最接近的2的幂**的大小，然后赋值给`threshold`。后续通过`resize()`方法将`threshold`赋值给`newCap`进行table的初始化。\n\n**tableSizeFor()**\n\n````java\n    /**\n     * Returns a power of two size for the given target capacity.\n     */\n    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n````\n\n\n\n\n\n##### putMapEntities方法\n\n即包含另一个“Map”的构造函数中会调用。\n\n````java\nfinal void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) {\n    int s = m.size();\n    if (s > 0) {\n        // 判断table是否已经初始化\n        if (table == null) { // pre-size\n            /*\n             * 未初始化，s为m的实际元素个数，ft=s/loadFactor => s=ft*loadFactor, 跟我们前面提到的\n             * 阈值=容量*负载因子 是不是很像，是的，ft指的是要添加s个元素所需的最小的容量\n             */\n            float ft = ((float)s / loadFactor) + 1.0F;\n            int t = ((ft < (float)MAXIMUM_CAPACITY) ?\n                    (int)ft : MAXIMUM_CAPACITY);\n            /*\n             * 根据构造函数可知，table未初始化，threshold实际上是存放的初始化容量\n             * 如果添加s个元素所需的最小容量大于初始化容量，则将最小容量扩容为最接近的2的幂次方大小作为初始化。\n             * 注意这里不是初始化阈值\n             */\n            if (t > threshold)\n                threshold = tableSizeFor(t);\n        }\n        // 已初始化，并且m元素个数大于阈值，进行扩容处理\n        else if (s > threshold)\n            resize();\n        // 将m中的所有元素添加至HashMap中，如果table未初始化，putVal中会调用resize初始化或扩容\n        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\n            K key = e.getKey();\n            V value = e.getValue();\n            putVal(hash(key), key, value, false, evict);\n        }\n    }\n}\n\n````\n\n\n\n##### put方法\n\n添加元素时调用，会调用`putVal()`方法\n\n添加元素的过程：\n\n1. 定位到的数组位置无元素，直接插入\n2. 有元素时，比较其与插入的`key`\n3. `key`相同时直接覆盖；`key`不同时判断 p 是否是一个树节点，如果是就调用`e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value)`将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。\n\n![image-20231211195415696](https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202312111954803.png)\n\n````java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    // table未初始化或者长度为0，进行扩容\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // (n - 1) & hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    // 桶中已经存在元素（处理hash冲突）\n    else {\n        Node<K,V> e; K k;\n        //快速判断第一个节点table[i]的key是否与插入的key一样，若相同就直接使用插入的值p替换掉旧的值e。\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n        // 判断插入的是否是红黑树节点\n        else if (p instanceof TreeNode)\n            // 放入树中\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        // 不是红黑树节点则说明为链表结点\n        else {\n            // 在链表最末插入结点\n            for (int binCount = 0; ; ++binCount) {\n                // 到达链表的尾部\n                if ((e = p.next) == null) {\n                    // 在尾部插入新结点\n                    p.next = newNode(hash, key, value, null);\n                    // 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法\n                    // 这个方法会根据 HashMap 数组来决定是否转换为红黑树。\n                    // 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    // 跳出循环\n                    break;\n                }\n                // 判断链表中结点的key值与插入的元素的key值是否相等\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    // 相等，跳出循环\n                    break;\n                // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表\n                p = e;\n            }\n        }\n        // 表示在桶中找到key值、hash值与插入元素相等的结点\n        if (e != null) {\n            // 记录e的value\n            V oldValue = e.value;\n            // onlyIfAbsent为false或者旧值为null\n            if (!onlyIfAbsent || oldValue == null)\n                //用新值替换旧值\n                e.value = value;\n            // 访问后回调\n            afterNodeAccess(e);\n            // 返回旧值\n            return oldValue;\n        }\n    }\n    // 结构性修改\n    ++modCount;\n    // 实际大小大于阈值则扩容\n    if (++size > threshold)\n        resize();\n    // 插入后回调\n    afterNodeInsertion(evict);\n    return null;\n}\n````\n\n\n\n##### resize()扩容\n\n进行扩容，会伴随一次重新hash分配，并会遍历hash表中的所有元素，非常耗时。\n\n实际上是将table初始化和table扩容进行了整合，底层行为都是给table赋值一个新的数组。\n\n**每次扩容都是扩大为原始大小的2倍。**\n\n````java\nfinal Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    if (oldCap > 0) {\n        // 超过最大值就不再扩充了，就只好随你碰撞去吧\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        // 没超过最大值，就扩充为原来的2倍\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1; // double threshold\n    }\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        // 创建对象时初始化容量大小放在threshold中，此时只需要将其作为新的数组容量\n        newCap = oldThr;\n    else {\n        // signifies using defaults 无参构造函数创建的对象在这里计算容量和阈值\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    if (newThr == 0) {\n        // 创建时指定了初始化容量或者负载因子，在这里进行阈值初始化，\n    \t// 或者扩容前的旧容量小于16，在这里计算新的resize上限\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    table = newTab;\n    if (oldTab != null) {\n        // 把每个bucket都移动到新的buckets中\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                if (e.next == null)\n                    // 只有一个节点，直接计算元素新的位置即可\n                    newTab[e.hash & (newCap - 1)] = e;\n                else if (e instanceof TreeNode)\n                    // 将红黑树拆分成2棵子树，如果子树节点数小于等于 UNTREEIFY_THRESHOLD（默认为 6），则将子树转换为链表。\n                    // 如果子树节点数大于 UNTREEIFY_THRESHOLD，则保持子树的树结构。\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else {\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do {\n                        next = e.next;\n                        // 原索引\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        // 原索引+oldCap\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    // 原索引放到bucket里\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    // 原索引+oldCap放到bucket里\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n````\n\n\n\n#### 为什么HashMap长度为2的幂\n\n为存取高效、减少碰撞，需将数据尽量分配均匀。\n\nHash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。\n\n用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。\n\n我们首先可能会想到采用`%`取余的操作来实现。但是，重点来了：**“ 取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&)操作（也就是说 hash%length==hash&(length-1)的前提是 length 是 2 的 n 次方；）。”** 并且**采用二进制位操作 &，相对于%能够提高运算效率**，这就解释了 HashMap 的长度为什么是 2 的幂次方。\n\n","tags":["Java","集合","HashMap","ArrayList","Set"],"categories":["Learning","Java"]},{"title":"MySQL索引","url":"/post/43a71ae4.html","content":"\n<!-- more -->\n\n# 存储引擎\n\n常见存储引擎有3种：MyISAM, MEMORY, InnoDB,\n\n|                      | MyISAM                                                       | InnoDB                                                       | MEMORY                                                       |\n| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 存储结构             | 每张表被存放在三个文件：<br />1. frm - 定义数据 <br />2. MYD (MYData)- 数据文件 <br />3.  MYI (MYIndex)- 索引文件 | 所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB | 将数据存在内存，为了提高数据的访问速度，每一个表实际上和一个磁盘文件关联。文件是frm。 |\n| 存储限制             | 256TB                                                        | 64TB                                                         | RAM                                                          |\n| 支持事务             | No                                                           | Yes                                                          | No                                                           |\n| 事务安全             | 不支持 每次查询具有原子性                                    | 支持。是具有事务 (commit)、回滚 (rollback) 和崩溃修复能力 (crash recovery capabilities) 的事务安全 (transaction-safe (ACID compliant)) 型表 |                                                              |\n| 支持全文索引         | Yes                                                          | No（5.6.4 以上支持英文全文索引） 可以通过使用 Sphinx 从 InnoDB 中获得全文索引，会慢一点 | No                                                           |\n| 支持B树索引          | Yes                                                          | Yes                                                          | Yes                                                          |\n| 支持哈希索引         | No                                                           | No                                                           | Yes                                                          |\n| 支持集群索引         | No                                                           | Yes                                                          | No                                                           |\n| 支持数据压缩         | Yes                                                          | No                                                           | No                                                           |\n| 支持外键             | No                                                           | Yes                                                          | No                                                           |\n| SELECT               | MyISAM更优                                                   |                                                              |                                                              |\n| INSERT               |                                                              | InnoDB更优                                                   |                                                              |\n| UPDATE               |                                                              | InnoDB更优                                                   |                                                              |\n| DELETE               |                                                              | InnoDB 更优 它不会重新建立表，而是一行一行的删除             |                                                              |\n| COUNT  without WHERE | MyISAM 更优。因为 MyISAM 保存了表的具体行数                  | InnoDB 没有保存表的具体行数，需要逐行扫描统计，就很慢了      |                                                              |\n| COUNT with WHERE     | 一样                                                         | 一样，无WHERE的情况InnoDB也会锁表                            |                                                              |\n| 锁                   | 只支持表锁                                                   | 支持表锁、行锁。行锁大幅度提高了多用户并发操作的性能。但是 **InnoDB 的行锁，只是在 WHERE 的主键是有效的，非主键的 WHERE 都会锁全表的。** | 表锁                                                         |\n|                      |                                                              |                                                              |                                                              |\n\n\n\n# 索引\n\n## 索引判断\n\n判断一条SQL是否使用索引，需通过执行计划进行判断：\n\n实现执行计划：在SQL前加上关键字`explain`，如：\n\n````SQL\nexplain select * from student where name = 'Mark'\n````\n\n则SQL执行结束后，会输出多个字段，其中某些关键字段为：\n\n| id   | select_type | table   | partitions | type | possible_keys | key    | key_len | ref    | rows | filtered | Extra  |\n| ---- | ----------- | ------- | ---------- | ---- | ------------- | ------ | ------- | ------ | ---- | -------- | ------ |\n| 1    | SIMPLE      | student | (Null)     | ALL  | (Null)        | (Null) | (Null)  | (Null) | 12   | 100.00   | (Null) |\n\n其中：\n\n* `type`：即为查询类型，即在表中找到所需行的方式。有以下几种类型（从上到下，性能越来越好）：\n\n  * ALL：全表扫描，即遍历全表以找到匹配的行。即直接遍历整个聚簇索引。\n\n  * index：全索引扫描，通过遍历所有索引来查找匹配的行.\n\n    > 直接在某个索引树上做条件判断，不需要回表。\n\n  * range：索引范围扫描，常见于`<`, `<=`, `>`,`>=` `between`等操作符.\n\n  * ref：普通的二级索引等值查询。\n\n    > 可能会查到多个匹配值，性能比const差一点。\n    >\n    > 由于null不能用const，所以不管是唯一索引还是二级索引值为null，都最多用到ref.\n\n  * eq_ref：多表连接查询时，被驱动表通过主键或唯一索引键进行等值查询\n\n  * const：使用主键或唯一索引等值查询来定位一条数据。因为索引的B+树都是矮胖的，定位一条唯一索引的记录，速度非常快，所以将该种查询定义为常数级，即为const.\n\n    > 唯一索引中允许多个null存在，所以对其进行null值查询，无法使用const\n\n  * system：是 const 类型的特例, 当查询的表只有一条数据的情况下使用 system.\n\n  * NULL：不用访问表或索引就直接能得到结果\n\n* `key`：执行本条SQL时，是否用到索引。\n\n* `Extra`：额外的可选信息。可以通过其判断当前SQL的执行效率。主要有：\n\n  * Using index：使用索引覆盖\n  * Using index condition：使用索引下推\n  * Using filesort：使用临时空间排序。\n\n\n\n索引种类\n\n目前MySQL提供了以下四种索引：\n\n1. B-Tree索引：最常见，大部分存储引擎都支持\n2. Hash索引：只有MEMORY引擎支持，使用场景简单\n3. R-Tree索引：又称空间索引，是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少。\n4. Full-text索引：又称全文索引，也是MyISAM引擎的一个特殊索引类型，主要用于全文检索，innoDB从mysql5.6开始支持全文索引。\n\n\n\n## 索引结构\n\n### 问题\n\n**Q1：索引过大无法加载到内存中怎么解决？**\n\nA1：分块读取。\n\n同时需要提高IO效率，在软件层面可以使用辅助手段提高。\n\n> 操作系统相关：\n>\n> 1. 局部性原理：\n>\n>    * 时间局部性：之前访问过的数据很可能再次被访问，至少比陌生数据概率大很多\n>    * 空间局部性：数据与程序都有聚集成群的倾向\n>\n> 2. 磁盘预读：\n>\n>    内存与磁盘交互的最小逻辑单位：页\n>\n>    其大小一般为4KB或8KB，由操作系统决定。在内存进行数据读取时，一般会读取页的整数倍。\n>\n> InnoDB引擎在进行数据加载时读取的就是**16KB**的数据，即为分块读取的集中体现。\n\n**Q2：why B+树？**\n\n索引存储的数据格式：key-value形式。\n\n能够存储key-value格式的数据结构有很多，如：hashmap，树，为什么最终选用B+树做索引？\n\n**首先，why not hashmap？**\n\n1. 利用hash存储需要将所有数据添加到内存，耗费内存空间\n2. 不合适的hash算法会导致hash冲突，以及会导致数据散列不均匀，空间浪费\n3. 哈希表存的key-value是无序的，进行范围查找时，需要遍历其中存储的所有数据，代价大。\n\nInnoDB自适应Hash。\n\n> **什么是自适应Hash？**\n>\n> InnoDB引擎会监控对表上二级索引的查找，如果发现某二级索引被频繁访问，二级索引成为热点数据，建立hash索引可以带来速度上的提升，则：\n>\n> 1. 自适应hash索引功能被打开\n> 2. 经常访问的二级索引数据会被自动生成到hash索引中去（最近连续被访问三次的数据）。\n>\n> 自适应hash索引通过缓冲池的b+树来构造，所以建立速度很快。\n>\n> **特点**\n>\n> 1. 无序，没有树高\n> 2. 降低对二级索引树的频繁资源访问\n> 3. 自适应\n>\n> **缺点**\n>\n> 1. 会占用innodb buffer pool\n> 2. 只适合搜索等值的查询，范围查找无法使用\n> 3. **MYSQL自动管理，无法人为干预**\n\n\n\n**其次，why not 二叉树、平衡二叉搜索树、AVL树、红黑树？**\n\n以上四种数据结构的共同点为：都为二叉树。即其每个分支上最多两个节点。\n\n当向其中插入大量数据时，无论其是否有序是否平衡，其树高度都会很大，导致在查找时，依然会存在多次比较操作，每次比较都相当于一次磁盘IO操作，会增加IO次数，影响效率\n\n> 为什么每次比较都相当于一次磁盘IO?\n>\n> 因为每个节点占用一个磁盘块，在比较时会将其中数据读取到内存中。\n\n则为了解决以上问题，可以从两个维度思考：\n\n1. 增加单个节点的范围：即单个节点的存值个数增加\n2. 增加节点的孩子个数\n\n因此，B树与B+树应运而生。\n\n\n\n### B树\n\n其为一棵平衡搜索多叉树。多叉，即为其孩子节点个数，也叫阶数，当我们描述一棵B或B+树时，需要指定其阶数，一般用`m`表示。\n\n定义：\n\n* 每个节点都有key-value\n  * 根节点至少有`1`对\n  * 非根节点至少有$\\lceil m/2 \\rceil$对\n  * 每个节点最多有`m-1`对\n* 所有叶子节点位于同一层\n* 除叶子节点外，所有节点的孩子数量为其当前的key-value对数 + 1\n* 每个节点中的key都按照排序规则从小到大排列，该节点左子树中所有key都小于它，右子树都大于它【开区间】\n\n\n\n查询过程为：如需查询key = 28的数据\n\n1. 由根节点找到磁盘块1，读入到内存中\n2. 比较得出28在区间16 ~ 34，找到磁盘块1中的指针p2\n3. 由p2找到磁盘块3，读到内存中\n4. 比较得出28在区间25 ~ 31，找到其中的指针p2\n5. 由p2找到磁盘块8，读到内存中\n6. 比较得出key=28的key-value，结束\n\n优点：降低了树高，虽然每次读进内存中的数据多，但是读取的次数少\n\n缺点：每个节点都有key-value，磁盘块/页的存储空间是有限的，所以当value很大时，能存储的key的数量减少。\n\n如何解决以上问题：\n\n在非叶子节点的磁盘页中不存value，只存储key，具体的key-value全部存储到叶子节点中。即B+树的方案。\n\n\n\n### B+树\n\n在B树的基础上进行优化，不同点为：\n\n* 非叶子节点只存储Key，叶子节点存储key-value\n* 每个叶子节点都有相邻叶子节点的指针\n* 子节点为左闭右开\n* 除叶子节点外，所有节点孩子数量等于当前的key-value数量\n\n\n\n查询数据：\n\n存在两种搜索方式：\n\n1. B树的搜索方式：$O(logN)$\n2. 链表搜索：叶子节点构成链表形成搜索，从最左下的叶子节点开始顺序搜索。\n\n优点：\n\n1. 非叶子节点只存储key，所以相比B树，能存储更多的Key，因此能更大地降低树高与将范围分成更多的区间，数据检索更快。\n2. 叶子节点都有相邻节点的指针，符合磁盘预读的特性，范围查询性能更快\n3. 一般三到四层的B+树足以支撑千万级别的数据存储，更大则需分表\n\n\n\nB+树所能存储的数据量计算：\n\n* 非叶子节点指针数：\n\n  InnoDB一个页的大小为16K，假设索引key的bigint占8个字节，指针占字节数为6，8 + 6 = 14，则一个page所能存放的key和指针个数为：16k / 14 ，约等于1170\n\n* 叶子节点记录数：\n\n  常规互联网单条行记录大小约为1k，则一个page能存储16k / 1k = 16条\n\n  * 如果为2层，则能存储记录数为：1170 * 16 = 18720\n  * 如果为3层，则能存储：1170 * 1170 * 16 约为2190w\n\n\n\n## 索引设计\n\n由上文分析，B+树非叶子节点的空间占用时，指针占用的为固定空间大小6个字节，所以影响其内存占用的因素为key\n\n* key为int：都占用4个字节\n\n* key为char：根据指定长度占用（英文字符一个长度一个字节，中文：utf8 - 3个, gbk - 2个）\n\n  > char(n) / varchar(n)：n表示字符数\n  >\n  > **char(n) vs. varchar(n)**\n  >\n  > * char(n)：\n  >   * 不管实际value的长度，都会占用n个字符的空间。【不够长则填充空格，固定长度】\n  >   * 存储时会自动截断尾部空格\n  >   * 上限255字节\n  >   * 不指定n时默认为1\n  > * varchar(n)：\n  >   * 占用value的实际空间 + 1，且该值 <= n。【可变长度】\n  >   * 不会截断尾部空格\n  >   * 上限65535字节【2^16】\n  >   * 不指定n时报错\n  >\n  > 空间占用超过n后，字符串会被截断\n  >\n  > **varchar vs. text**\n  >\n  > * text：用于保存文本类型的字符串，有四种类型：\n  >\n  > | 文本字符串类型 | 特点               | 长度 | 长度范围                         | 占用的存储空间 |\n  > | :------------- | :----------------- | :--- | :------------------------------- | :------------- |\n  > | TINYTEXT       | 小文本、可变长度   | L    | 0 <= L <= 255                    | L + 2 个字节   |\n  > | TEXT           | 文本、可变长度     | L    | 0 <= L <= 65535                  | L + 2 个字节   |\n  > | MEDIUMTEXT     | 中等文本、可变长度 | L    | 0 <= L <= 16777215               | L + 3 个字节   |\n  > | LONGTEXT       | 大文本、可变长度   | L    | 0 <= L<= 4294967295（相当于4GB） | L + 4 个字节   |\n  >\n  > 由于实际存储的长度不确定，MySQL 不允许 TEXT 类型的字段做主键\n  >\n  > **varchar转换为text**\n  >\n  > 1. 大于varchar（255）变为 tinytext\n  > 2. 大于varchar（500）变为 text\n  > 3. 大于varchar（20000）变为 mediumtext\n  >\n  > **为什么经常使用varchar(255)？**\n  >\n  > MYSQL5.6及以前，InnoDB支持的前缀索引最大为767个字节，采用utf8编码时， $\\lfloor 767 / 3 \\rfloor = 255$\n  >\n  > 255刚好为能建立前缀索引的最大值，不是最优，但是能减少出错\n\n目标：让key占用尽可能少的空间\n\n\n\n### 前缀索引\n\n**索引的选择性Index Selectivity** =  基数 / 数据表的总记录数【即为唯一索引值占比】\n\n> 基数为不重复索引值的数量，即唯一索引值数量\n>\n> MYSQL中使用HyperLogLog做基数统计，这是一个预估值。\n\n索引的选择性越高，查询效率越高，但是所占用的空间也就越多。\n\n\n\n**前缀索引定义**\n\n选择目标列的部分字符作为索引，从而节约空间，提高索引效率，但是会降低索引的选择性。【性能与空间之间寻找平衡】\n\n大部分存储引擎都支持前缀索引，目前只有字符类型或二进制类型的字段可以建立前缀索引，如：CHAR/VARCHAR、TEXT/BLOB、BINARY/VARBINARY\n\n* 字符类型基于前缀字符长度\n* 二进制类型基于字节大小\n* TEXT/ BLOB类型只支持前缀索引，不支持整个字段建索引。\n\n\n\n怎么选定合适的前缀？即如何确定合适的前缀长度？\n\n1. 统计指定字段出现重复值最多的前10个以及其重复出现次数\n\n   ````sql\n   select count(*) as count, city_name from city group by city_name order by count desc limity 10;\n   ````\n\n2. 统计该字段前3个字符出现重复值最多的前10个以及其重复出现次数\n\n   ````sql\n   select count(*) as count, left(city_name, 3) as prefix from city group by prefix order by count desc limit 10;\n   ````\n\n   > left(str , length)返回指定str从左边返回length长度的字符串\n\n3. 观察第1次与第2次统计结果差距大不大，如果大，则向右扩1个字符，在比较前3个和前4个字符的统计结果【如果仍然差距大，继续扩展重复】\n\n4. 知道结果差不多，则当时的前n个字符可作为前缀索引的最终长度，以此建立前缀索引\n\n优点：索引更小，节约索引空间，提高索引效率\n\n缺点：\n\n* 降低索引的选择性\n* 无法使用前缀索引做groupby和orderby，也无法做覆盖扫描\n\n\n\n### 聚簇 / 非聚簇索引\n\n并不是一种单独的具体索引类型，而是一种数据存储方式，具体依赖于其实现方式。\n\n\n\n#### 聚簇索引\n\n即Clustered Index。\n\n定义：按表的主键构造一棵B+树，叶子节点存放表的行记录数据，即将表的索引与数据存储在一起，找到索引的同时也找到了数据。\n\n按照以上定义，很显然**一张表只能有一个聚簇索引**。\n\nInnoDB中存储主键选用的就是聚簇索引的方式，如果未定义主键，则会选择非空唯一性(not null unique)字段，若不存在，则会隐式定义一个长整型，占6个字节的rowid作为主键来作为聚簇索引。\n\n\n\n#### 非聚簇索引\n\nNon-Clustered Index，也叫辅助索引或二级索引。\n\n非聚簇索引为在聚簇索引上创建的索引，即将数据与索引分开存储。\n\n常见非聚簇索引：\n\n* 复合索引\n* 前缀索引\n* 唯一性索引\n* MyISAM中的主键做因\n\n同样由B+树构成，但是树的叶子节点不再存储表的行记录数据，而是主键或指定索引字段\n\n* InnoDB中，存储的未主键\n* MyISAM中，主键索引存的是主键。非主键索引存的是指定索引字段。\n\n如：存在表user，id为主键，name字段有索引，除此之外还有一个字段为company\n\n则以下两个SQL：\n\n````sql\nselect * from user where id = 7;\nselect * from user where name = 'Jobs';\n````\n\nInnoDB中其查找流程为：\n\n【】\n\n\n\nSQL1：聚簇索引查找，主键为聚簇索引，所以可以直接通过主键查找到对应叶子节点，访问行记录\n\nSQL2：非聚簇索引查找，InnoDB除主键外都是非聚簇索引，通过二阶索引的B+树查询到其对应的主键id，然后再在主键索引建立的B+树中查询到对应的叶子节点，访问行数据。\n\n> 以上操作也叫**回表**。即包含两次具体的查询动作，非聚簇索引查找性能低，在能使用聚簇索引解决的情况下，尽量规避使用回表查询。\n\n\n\nMyISAM中查询流程为：\n\n【】\n\n\n\nSQL1与SQL2都为非聚簇索引查找。\n\nMyISAM中无无论是主键索引还是非主键索引，都为非聚簇索引。其B+树中叶子节点还需存储地址，指向表中的某一行，因此，每个B+树都相互独立，不需要相互访问【与InnoDB不同】\n\n\n\n聚簇索引优缺点：\n\n优点：\n\n1. 查找速度快于非聚簇索引，因为在InnoDB中无需二次查询，在MyISAM中无需寻址\n2. 聚簇索引行数据在叶子节点中，同一个数据页可能有多条行数据，访问同一数据页的不同行数据是，其已被加载到内存中，再次访问可以直接在内存中访问，减少了IO\n3. InnoDB中使用主键值做非聚簇索引的value而非地址，是为了保证B+树分裂时，出现行移动的情况下，主键索引的B+树的变化不会影响非主键索引。\n4. 适用于排序场合、选取一定范围数据的场景\n\n缺点：\n\n1. 一张表中只能有一个聚簇索引，可以有多个非聚簇索引\n\n2. 维护聚簇索引很昂贵，因为行移动会造成碎片\n\n3. 若使用UUID(通用唯一标识码)做主键，其本身特性会导致数据稀疏，则会出现使用非聚簇索引查询速度慢于全字典扫描，因此建议用自增主键做聚簇索引。\n\n   > 为什么？\n   >\n   > 因为聚簇索引的数据的物理存放顺序与索引顺序是一致的，只要索引相邻，则对应数据也存放在相邻磁盘上。\n   >\n   > 如主键不是自增id，则不可能顺序插入，存储引擎会不断调整数据的物理地址，会不断分页。\n   >\n   > 若主键为自增id，则只需一页一页写入数据，索引结构也相对紧凑，磁盘碎片少，效率更高。\n\n如果涉及到大量数据的排序、全表扫描、count之类的操作的话，建议使用MyISAM引擎。因为所有占用空间小，这些操作是需要在内存中完成的。\n\n\n\n### 索引覆盖\n\ncovering inex\n\n当`explain`命令输出结果的`Extra`字段为：`Using index`时，则可触发索引覆盖 / 覆盖索引。\n\n定义：只要在一棵索引树上就能获取SQL所需的所有数据，无需回表。\n\n实现：将被查询的字段，建立到**联合索引**中\n\n如：存在表user，id为主键，name字段有普通索引，除此之外还有一个字段为company\n\n以下两条SQL：\n\n````sql\n# 1\nselect id, name from user where name = 'Gates';\n# 2\nselect id, name, company from user where name = 'Gates';\n````\n\nSQL1：name字段索引的B+树，访问name字段后可以获得对应的id，满足所需数据，无需回表，符合覆盖索引，效率高。\n\nSQL2：前面等同于SQL1，获取name和id后，无法在当前B+树获取company字段，需要二次查询聚簇索引获得company字段，回表，效率底。\n\n解决方案：将索引建立时：`index(name)`升级为联合索引`index(name, company)`，则再次执行SQL2，等同于SQL1执行过程。无需回表，符合索引覆盖，效率高。\n\n\n\n### 联合索引\n\n#### 最左匹配原则\n\n建立联合索引时需遵循最左匹配原则。\n\n如创建一个索引`index(a , b)`，则其B+树为以下：\n\n【】\n\n`a`字段是有序的，而`b`字段是建立在`a`字段的基础上的，所以在固定`a`字段上来看是有序的，整体看是无序的。\n\n什么条件查询才能利用联合索引呢？\n\n由以上B+树，b字段只有在a字段固定时才有序，所以：\n\n1. where b = 2：无法使用联合索引，索引整体按照a字段排序，无法单独确定b\n2. where a = 2 and b = 2：可以使用\n3. where a > 2 and b = 2：a使用，b未使用。在a字段的固定范围中，b依然整体是无序状态\n\n由以上可以得出**最左匹配定义**：查询条件中，以联合索引最左边定义的字段为起点，且所有字段和顺序都与联合索引中一致，构成的查询条件能够利用联合索引，查询条件中出现**范围查询、模糊查询、排序则需具体分析**。\n\n**注**：查询条件没有按联合索引的顺序排列时：同级查询会被MYSQL中的查询优化器**自动优化查询顺序**，即尽量会满足按照联合索引顺序排列。**MySQL的查询优化器无法对于group by，order by进行优化**\n\n[索引是否失效：](https://dbaplus.cn/news-11-4972-1.html)\n\n**范围查询**：\n\n1. `>`, `<`：最左用到了联合索引，范围之后的不会使用\n2. `>=`, `<=`：最左使用了，范围之后的对于`=`的情况用到了\n3. `between x and y`：mysql中是闭区间，所以对于边界值等于的地方，范围也用到了联合索引。\n\n**模糊查询like**：\n\n当涉及字符型数据的模糊查询和范围查询时，除最左原则外，还需考虑其本身是否能通过B+树查询。\n\n如：\n\n````sql\n// SQL1\nselect * from user where name like 'Ga%';\n// SQL2\nselect * from user where name like '%tes';\n````\n\nSQL1符合最左，提提供了查询前缀，使用联合索引。\n\nSQL2符合最左，但是只提供了中缀，无法在B+树上进行节点搜索，所以无法使用联合索引。\n\n\n\n多条件情况：\n\n````sql\nselect * from user where company like 'Mic%' and name like 'Ga%';\n````\n\n首先优化器会自动优化为`name`在前，`company`在后。\n\n对于name字段进行查询，形成的区间为`['Mic~','Mid~')`，虽然在符合Mic为前缀的name的二级索引范围中，company是无序的，但是对于符合name = Mic的记录中，company的值是有序的，所以company字段也会用到联合索引。\n\n\n\n**Q：使用`like \"%x\"`，索引一定会失效吗？**\n\n**A**：不一定，取决于表中字段数量，如果表中所有字段都有索引，则走的为全扫描二级索引B+树。\n\n比如只有两个字段，id为聚簇索引，name为普通索引。\n\n````sql\nselect * from user where name like \"%tes\";\n````\n\n则直接全扫描二级索引B+树则可得到想要结果，无需回表，保证了索引覆盖\n\n\n\n## 常见索引失效\n\n1. 模糊查询非前缀\n\n2. 对索引使用函数。因为索引保存的是字段原始值，而不是经过函数计算后的值，所以使用函数计算后就无法再使用索引了。\n\n   > MySQL8.0开始增加了函数索引，即可以对函数计算后的值建立索引。\n   >\n   > 如：\n   >\n   > ````SQL\n   > alter table t_user add key idx_name_length ((length(name)));\n   > ````\n\n3. 对索引进行表达式计算，原因类似使用函数\n\n4. 对索引进行隐式类型转换\n\n   >如：phone字段定义的为varchar，但是查询时：\n   >\n   >````sql\n   >select * from user where phone = 12345678901;\n   >````\n   >\n   >则会走全表扫描。\n   >\n   >因为其等价于：\n   >\n   >````sql\n   >select * from user where CAST(phone AS signed int) = 12345678901;\n   >````\n   >\n   >则**相当于对索引字段使用了函数。**\n   >\n   >**但是**，id字段定义为int，查询：\n   >\n   >````sql\n   >select * from user where id = '1';\n   >````\n   >\n   >会正常使用索引。\n   >\n   >为什么？\n   >\n   >MySQL会自动将字符串转为数字。\n   >\n   >其等价于：\n   >\n   >````sql\n   >select * from user where id = CAST('1' AS signed int);\n   >````\n   >\n   >CAST 函数是用在了输入参数，因此是可以走索引扫描的。\n\n5. 联合索引非最左匹配【见最左匹配部分】\n\n6. `WHERE`子句中的`OR`\n\n   > 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。\n   >\n   > 因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。\n   >\n   > 解决方案：增加索引列\n\n\n\n## 索引下推\n\nindex condition pushdown，ICP，全称为索引条件下推优化。MySQL5.6推出，默认开启，用于优化查询。\n\n使用索引下推的表示：explain 结果中的Extra值为Using index condition\n\n\n\n### 原理\n\nMySQL架构：\n\n* Client\n* Server\n* 存储引擎\n\n**未使用ICP时，MySQL如何查询？**\n\n1. 存储引擎读取索引记录\n2. 根据索引中的主键值，定位并读取完整的行记录\n3. 存储引擎把记录交给`Server`层去检测该记录是否满足`WHERE`条件\n\n**使用ICP后，查询过程为：**\n\n1. 存储引擎读取索引记录（不是完整的行记录）\n2. 判断`WHERE`条件部分是否能用索引中的列来做检查【即做一次筛选过滤】\n   * 条件不满足则处理下一条索引记录\n   * 条件满足，回表读取完整行记录\n3. 存储引擎把记录交给`Server`层，`Server`层检测该记录是否满足`WHERE`条件的其余部分\n\n\n\n### 使用条件\n\n* 只能用于`range`, `ref`, `eq_ref`, `ref_or_null`访问方法\n\n* 只能用于InnoDB和MyISAM存储引擎及其分区表\n\n* 对InnoDB而言，ICP只适用于二级索引\n\n  > 为什么？\n  >\n  > 因为ICP的目的是**减少回表次数**，而对聚簇索引而言，其完整的行记录已经在缓存区，ICP无意义。\n\n* 引用了子查询的条件不能下推\n\n* 引用了存储函数的条件不能下推，因为存储引擎无法调用存储函数。\n\n\n\n## count()性能问题\n\n### count()作用\n\ncount()作用：统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个。\n\n* count(name)：统计表中name不为空的记录条数\n* count(1)：在当前表中，1永远不为空，所以统计的为当前表的记录总数\n* count(*)：当前表中记录总数\n\n\n\n### count(primary key)执行过程\n\n1. Server层维护名为count的变量\n2. Server层循环向InnoDB中读取一条记录，id不为NULL，则count += 1\n3. 所有记录读取完毕，退出循环，将count变量值发送给Client\n\nInnoDB遍历选择：\n\n* 无二级索引：遍历聚簇索引\n* 有二级索引：遍历二级索引【树更小】【优化器选择】\n\n\n\n### count(1)执行过程\n\nInnoDB遍历选择：\n\n* 无二级索引：遍历聚簇索引，但是**不会读取value**\n* 有二级索引：遍历二级索引【树更小】【优化器选择】\n\n\n\n### count(*)执行过程\n\n对于`select *`而言是读取所有记录，但是对于count不是\n\n`count(*)`相当于`count(0)`，所以，其执行过程与`count(1)`相同\n\n\n\n### count(字段)执行过程\n\n如`count(name)`，name不为索引\n\n会采用全表扫描的方式，所以效率很低。\n\n\n\n### 性能对比\n\ncount(1) = count(*) > count(primary key) > count(字段)\n\n\n\n### count(*)优化\n\n数据量过大时，count(*)也很耗时，如何优化？\n\n1. 近似值：当无需精确值统计时，可以使用近似值，如使用`show table status`或`explain`来估算\n\n2. 额外表保存字段：如果是想精确的获取表的记录总数，我们可以将这个计数值保存到单独的一张计数表中。\n\n   当我们在数据表插入一条记录的同时，将计数表中的计数字段 + 1。也就是说，在新增和删除操作时，都需要额外维护这个计数表。\n\n\n\n参考：\n\n[【MySQL】索引进阶(B+树，前缀索引，聚簇索引等)](https://juejin.cn/post/7028851379078692895)\n\n[MySQL一个全网都在说的错误结论](https://dbaplus.cn/news-11-4972-1.html)\n\n[一文读懂什么是MySQL索引下推（ICP）](https://www.jianshu.com/p/31ceadace535)\n\n","tags":["MySQL","存储引擎","索引"],"categories":["Learning","DataBase"]},{"title":"数位DP思路","url":"/post/da4a5ffe.html","content":"\n\n\n一般用于统计某个范围的数，而这个范围一般都很大，难以直接暴力枚举求解，所以一般将其每位数拆分，一位一位地看。\n\n<!-- more -->\n\n如：判断在`[0,x]`范围中，满足某条件的数的个数\n\n**先做规约：**\n\n* 0特殊判断，然后数位dp判断`[1,x]`\n* 不填前导0，即保证每个数的最高位为正数\n\n**填数过程，遵循以下：**\n\n* 从高位往低位枚举数位\n* 在第`i`位填上了数，则其后面的数位都需填上数，保证数据不重复\n* 保证填入的数组成的数据不大于x\n\n\n\n如：令`x = 324783729`，求`[1,x]`内有多少个数满足其数位上的数字之和为16\n\n1. 先看第一位：\n   * 不填\n   * 填：可以填1, 2, 3\n2. 再看第二位：\n   * 不填\n   * 填：\n     * 第一位没填数：可以填[1,9]任意一个数\n     * 第一位填数了：\n       * 第一位填的1或2：可以填[0,9]任意一个数\n       * 第一位填的3：可以填[0,2]任意一个数\n3. ...\n4. 如处理到第七位：\n   * 不填\n   * 填：\n     * 前面都没有填数：可以填[1,9]任意一个数\n     * 前面填了：\n       * 前面位数没满，即前面填的数没有六位：可以填[0,9]任意一位数\n       * 前面数位满了：\n         * 前面存在一位，其数字小于其对应的数字，即nums[i]：可以填[0,9]任意一位数\n         * 前面所有数字都与对应数字相同：可以填[0,7]任意一位\n\n**规律分析总结：**\n\n第`i`位填数：\n\n* 前面都没有填数：[1,9]\n* 前面没填满或填满了但存在一位所填的数小于x中对应位数的数值：[0,9]\n* 前面所有数字都与x中对应数字相同：[0, nums[i]]\n\n所以，可以引入变量`limit`来判断前面所填数字是否都与x中对应数字相同\n\n则在填入第一个数时，即情况1，前面都没有填数时，对`limit`进行初始化\n\n第二种情况下：limit = 0\n\n第三种情况下： limit = 1\n\n\n\n**limit转移：**\n\n填完第`i`个数字，`limit`怎么转移到第`i + 1`位：\n\n当前limit = 1且填入的数字为nums[i]，则下一位的limt = 1;\n\n否则下一位的limit = 0;\n\n\n\n**特殊情况处理：**\n\n即最高位，第0位的处理\n\n其填入的值的范围：[1, nums[0]]\n\n其limit = 填值 == nums[i] ? 1 : 0\n\n\n\n分析转移方程：使用`dp[i][limit][sum]`表示在前`i`位数字和为sum的数据个数\n\n* 前面都没有填数：[1,9]\n\n  ````java\n  //初始化\n  //填入数字为c,取值为1，9\n  dp[i][0][c] = 1;\n  ````\n\n* 前面没填满或填满了但存在一位所填的数小于x中对应位数的数值：[0,9]\n\n  ````java\n  dp[i][0][cur_sum + c] += dp[i - 1][0][cur_sum];\n  ````\n\n  \n\n* 前面所有数字都与x中对应数字相同：[0, nums[i]]\n\n  ````java\n  c != nums[i]\n  dp[i][0][cur_sum + c] += dp[i - 1][1][cur_sum];\n  else c == nums[i]\n  dp[i][1][cur_sum + c] += dp[i - 1][1][cur_sum];\n  ````\n\n* 最终答案为：\n\n  ````java\n  dp[n - 1][0][sum] + dp[n - 1][1][sum]\n  ````\n\n  ","tags":["数位DP","算法"],"categories":["Learning","Algorithm"]},{"title":"集成JWT实现token验证与注销","url":"/post/0.html","content":"JWT（Java Web Token）定义了一种简洁的，自包含的方法用于通信双方之间以 `JSON` 对象的形式安全的传递信息。因为数字签名的存在，这些信息是可信的，JWT 可以使用 `HMAC` 算法或者是 `RSA` 的公私秘钥对进行签名。\n\n<!-- more -->\n\n## 流程\n\n![图片.png](https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309022123414.png)\n\n1. 用户使用账号和面发出 post 请求；\n2. 服务器使用私钥创建一个 jwt；\n3. 服务器返回这个 jwt 给浏览器；\n4. 浏览器将该 jwt 串在请求头中向服务器发送请求；\n5. 服务器验证该 jwt；\n6. 返回响应的资源给浏览器。\n\n\n\n## JWT结构\n\n包含三个部分：\n\n1. Header 头部 (包含了令牌的元数据，并且包含签名和 / 或加密算法的类型)\n2. Payload 负载 (类似于飞机上承载的物品)\n3. Signature 签名 / 签证\n\n以上三段信息用`.`连接在一起，构成了JWT字符串\n\n\n\n### Header\n\n包含两部分信息：\n\n1. token类型\n2. 采用的加密算法\n\n````\n{ \n  \"alg\": \"HS256\",//加密算法，通常直接用HMAC SHA256\n   \"typ\": \"JWT\" //类型\n}\n````\n\n\n\n### Payload\n\n载荷就是存放有效信息的地方\n\n有效信息包含：\n\n1. 标准中注册的声明\n2. 公共的声明\n3. 私有的声明\n\n\n\n### 1. 标准中注册的声明\n\n建议但不强制使用\n\n* iss: jwt 签发者\n* sub: 面向的用户 (jwt 所面向的用户)\n* aud: 接收 jwt 的一方\n* exp: 过期时间戳 (jwt 的过期时间，这个过期时间必须要大于签发时间)\n* nbf: 定义在什么时间之前，该 jwt 都是不可用的.\n* iat: jwt 的签发时间\n* jti: jwt 的唯一身份标识，主要用来作为一次性 token, 从而回避重放攻击。\n\n\n\n#### 2. 公共的声明\n\n可以添加任何信息。一般添加用户的相关信息或其他业务需要的必要信息。\n\n不建议添加敏感信息，因为该部分在客户端可解密。\n\n\n\n#### 3. 私有的声明\n\n为提供者和消费者所共同定义的声明。\n\n不建议存放敏感信息，因为base64是对称解密的，即该部分信息可以归类为明文信息\n\n\n\n### Signature\n\n签证信息，包含以下三部分：\n\n1. header(base64后)\n2. payload(base64后)\n3. seceret\n\n需要 base64 加密后的 header 和 base64 加密后的 payload 使用`. `连接组成的字符串，然后通过 header 中声明的加密方式进行加盐 secret 组合加密，然后就构成了 jwt 的第三部分。\n密钥 secret 是保存在服务端的，服务端会根据这个密钥进行生成 token 和进行验证，所以需要保护好。\n\n\n\n## Springboot和jwt集成\n\n1. 引入jwt依赖\n\n   ````xml\n   <dependency>\n         <groupId>com.auth0</groupId>\n         <artifactId>java-jwt</artifactId>\n         <version>3.4.0</version>\n   </dependency>\n   ````\n\n2. ","tags":["studying","springboot","jwt","token"],"categories":["Coding","Mo1isting"]},{"title":"遇到的问题及思路","url":"/post/0.html","content":"\n\n\n\n一些开发过程中的问题rec.\n\n<!-- more -->\n\n\n\n1. maven直接引入jdbc失败，搜索后发现时maven3后oracle不支持直接引入了，手动下载jdbc引入，使用如下命令：\n\n   ````shell\n   mvn install:install-file -Dfile=D:\\Code\\oracle\\ojdbc11.jar -DgroupId=com.oracle -DartifactId=ojdbc11 -Dversion=11 -Dpackaging=jar -DgeneratePom=true\n   ````\n\n   但是报错误：\n\n   ````\n   [ERROR] Unknown lifecycle phase \".oracle\". You must specify a valid lifecycle phase or a goal in the format <plugin-pre\n   fix>:<goal> or <plugin-group-id>:<plugin-artifact-id>[:<plugin-version>]:<goal>. \n   ````\n\n   查询后发现为使用powershell的问题，应该是powershell对`.`的判定规则引起，切换到cmd后正常\n\n   参考：https://blog.csdn.net/without_mercy/article/details/81474648\n\n2. https://jasonkayzk.github.io/2020/01/25/%E5%85%B3%E4%BA%8EMybatis-plus%E8%B0%83%E7%94%A8baseMapper%E6%8A%A5%E9%94%99Invalid-bound-statement%E7%9A%84%E8%A7%A3%E5%86%B3/\n\n   以及记得关闭下划线驼峰转换：\n\n   ````\n   mybatis:\n     configuration:\n       map-underscore-to-camel-case: false #下划线转驼峰\n   ````\n\n   \n\n   \n\n","tags":["问题","Mo1isting"],"categories":["Coding","Mo1isting"]},{"title":"It should be in Theater - 其实是剧推荐","url":"/post/94b1f2b2.html","content":"\n\n\n随着年纪的增加，对不同音乐的喜好程度有了很大变化。\n\n就该在剧院！很主观的剧目推荐。\n\n大致有：\n\n* 音乐剧\n* 话剧\n* 舞剧\n\n <!-- more -->\n\n# 音乐剧\n\n## Hamilton\n\n![image-20230928164639070](https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281646018.png)\n\n目前仍是我的最爱之一，很难想象为什么会有LMM这么天才的人。\n\n舞美、剧情、演唱都非常非常好看，在我这儿属于不看非常亏的剧。希望有天能看到现场。\n\n喜爱程度：⭐⭐⭐⭐⭐\n\n目前可以看[Disney的官摄版本](https://tv.apple.com/movie/hamilton/umc.cmc.54rv4esv3qomlthreamvbd34v?at=11l4BH&itscg=30200&itsct=tv_box_link)\n\n\n\n## Rent\n\n![RENT - O MUSICAL](https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281632766.jpeg)\n\n再放一张很喜欢的：\n\n![rent](https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281636284.png)\n\n其实某种意义上这算是我的第一步音乐剧。诚挚、动人，在混乱的世界怎么才能pay自己的rent，最喜欢的是那句\n\n**Everything is Rent**\n\n很触动内心。而且这部剧的歌，都好好听，每一首都是精品。\n\n喜爱程度：⭐⭐⭐⭐⭐\n\n推荐查看[2008Broadway Film](https://www.imdb.com/title/tt1273675/)版\n\n\n\n## SIX\n\n![SIX | Broadway in Spokane](https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281644058.jpeg)\n\n该怎么形容？真的太太太太好看了，不好描述所以推荐每个人都去看一遍。\n\n喜爱程度：⭐⭐⭐⭐⭐\n\n目前无官摄，最近在韩巡，希望有一天能看到现场！\n\n\n\n## Les Misérables\n\n![Les Misérables – Hennepin Theatre Trust](https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281649714.jpeg)\n\n谁能不看？\n\n非常非常喜欢10th的音乐会，只能说看了的都不会不喜欢。\n\n喜爱程度：⭐⭐⭐⭐⭐\n\n23年法语版音乐会会到国内巡，英语的没听说。\n\n推荐看[10th的音乐会官摄](https://www.imdb.com/title/tt11918512/)。25th的也还行。\n\n\n\n## SpringAwakening\n\n![image-20230928165811680](https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281658375.png)\n\n如果你也喜欢死亡诗社，那你肯定会喜欢这部剧。\n\n值得所有人看。\n\n喜爱程度：⭐⭐⭐⭐⭐\n\n目前有很多版本，都可以看。\n\n\n\n## Dear Evan Hansen\n\n![Dear Evan Hansen – Official Website of the Morris Performing Arts Center](https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281640618.jpeg)\n\n其实这个故事并不算很触动我，但是ben的演绎我觉得太适合了，第一次见他是在Pitch Perfect1，当时我觉得他就很适合这类角色，看了evan国货发现我曾经的觉得太对了，很迷茫很恐怯，演得太好了，歌也非常非常好听！\n\n喜爱程度：⭐⭐⭐⭐\n\n目前无官摄。\n\n\n\n## Anastasia\n\n![Anastasia | The Musical - Video Dailymotion](https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281654838.jpeg)\n\n感觉是一部很冷门的剧，但是舞美非常妙非常好看，切换也很好看。\n\n有官摄可看。\n\n喜爱程度：⭐⭐⭐⭐\n\n\n\n## Mozart!\n\n![Mozart! Das Musical - Vorstellungen & Tickets](https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281700457.jpeg)\n\n我的人生挚爱剧之一。\n\n非常非常非常喜欢。\n\n希望有一天能巡。\n\n喜爱程度：⭐⭐⭐⭐⭐\n\n推荐看2015官摄版，同时非常推荐Thomas Hohler2019上海巡演版\n\n\n\n## Elisabeth\n\n![Elisabeth\" in Wien (2004) | Seite 2 von 5 | Mucke und mehr](https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281707893.jpeg)\n\n也是人生剧之一，看的maya和麻袋版，serkan太帅了，唱得太好听了。\n\n表哥版据说也很不错。\n\n喜爱程度：⭐⭐⭐⭐⭐\n\n\n\n\n\n## Notre-Dame de Paris\n\n![Notre Dame de Paris (Musical)](https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281704637.jpeg)\n\n非常非常完美的一部剧\n\n喜爱程度：⭐⭐⭐⭐⭐\n\n有官摄可看，虽然很糊\n\n\n\n# Mozart, L'Opéra Rock\n\n![image-20230928171004655](https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281710900.png)\n\n因为太喜欢德扎了所以我觉得一般，不过歌很好听。\n\n喜爱程度：⭐⭐⭐⭐\n\n有官摄可看。\n\n\n\n## 粉丝来信\n\n![聚焦1940年代上海文学青年，音乐剧《粉丝来信》来了_郑微岚_徐均_中文版](https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281712727.jpeg)\n\n我真的挺喜欢的，歌也挺好听的，5.20午场演得也很不错。\n\n喜爱程度：⭐⭐⭐⭐\n\n目前还在巡，会再去刷。\n\n可以看韩版官摄。\n\n\n\n\n\n# 话剧\n\n## 蒋公的面子\n\n![喜剧《蒋公的面子》讲了一个什么故事？-黄河票务网](https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281714186.jpeg)\n\n很好看，整体节奏紧凑，语言幽默，非常有意思。\n\n目前在南京驻演，全国偶尔巡演。\n\n喜爱程度：⭐⭐⭐⭐⭐\n\n\n\n## 惊梦\n\n![img](https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281718618.jpeg)\n\n非常好看，整体剧情，演绎，节奏都很舒服，适当的幽默，全程只使用天地麦，非常好看，总让我想到莫言的《檀香刑》。看一场少一场，碰到巡演一定冲冲冲！\n\n喜爱程度：⭐⭐⭐⭐⭐\n\n\n\n# 舞剧\n\n## 红楼梦\n\n![image-20230928173423264](https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281734566.png)\n\n太太太喜欢了，已经看过两次了，想再看无数次！\n\n一直在巡，票很难买。\n\n喜欢程度：⭐⭐⭐⭐⭐\n\n\n\n## 永不消逝的电波\n\n![img](https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281726845.jpeg)\n\n好喜欢，剧情流的。今年末会在南京演，期待期待。\n\n喜爱程度：⭐⭐⭐⭐⭐\n\n\n\n## 只此青绿\n\n![舞蹈诗剧：只此青绿– 舞绘千里江山图](https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202309281728805.jpeg)\n\n意识流，很美。年末也会巡到南京嘿嘿。\n\n喜爱程度：⭐⭐⭐⭐⭐\n\n\n\n\n\n","tags":["thoughts","Music","theater","I'm alive"],"categories":["Let's think","Life"]},{"title":"2022.8-2022.9暑期学校总结","url":"/post/6ba0d0e7.html","content":"\n  很难形容的一个月，确实增长了不少见识。\n\n<!-- more -->\n\n如果非得让我列一下时间线，那应该是\n\n1. 暑期初始，校企发布让大家选项目的要求以及多次@全体成员\n  * 心情：无语+心烦\n2. 填完项目后，暑期中后段，发布分组情况，要求大家在暑假期间完成训前作业\n\n   * 心情：得知分组为我+两个隔壁班同学+一个狂重修哥，心情复杂，非常不道德地去查了隔壁俩同学的绩点，了解基本情况后晴天霹雳，当时和朋友聊天出现得最多的词语是“麻麻的”。本来准备我当组长好了，结果隔壁有个同学拉群了，询问大家当组长的意愿，不知道怎么脑子抽了说自己也不想当组长，隔壁某同学遂成为组长，胡乱分工开始训前作业。\n   * 当时分完工还和朋友说可能没有想得那么差，如今看来当时已经铺好了烂掉的基石。\n   * 得知分组后第一时间开始学习前端相关知识。说来其实也很好笑，本来未放假时的计划就是学习前端知识，结果回家了一点儿没实施，但是分组结果一出来就马上去学了，果然是有压迫才有动力.....\n\n3. 临近开学，合训前作业\n\n   * 以为自己在来学校前一天正式写完就是最慢了，结果貌似除了我没人写完，合模块也相当于没有合，只是随意拼凑。\n   * 再次对分组感到无语+心灰意冷\n\n4. 正式开学开始实训，线上写文档\n\n   * 反感企业老师只是装模做样而讲不出有价值的知识点；反感小组没有交流或是交流后没有有用的结果；反感每次分工都是按照demo的页数进行分工，没有根据自己的项目进行；反感每次分工都是“先到先得”，没有相对合理地安排大家的工作。\n   * 开始后悔自己为什么不当组长。\n\n5. 三天过后线下写文档\n\n   * 天气真的好热，到教室也是大家开腾讯会议上课。不明白为什么要这样，开始无止境的抱怨，生气，写文档依然重复之前的模式，甚至出现了我因为完成了自己的任务而必须开始接受未分配的新任务，没完成的不用因为他们“任务重”.....\n   * 第一天线下就碰到了勤工俭学的老师，于是收放排插的任务自然而然地被交给了我和yc同学，真的很累，也有一点尴尬，开始自己生闷气\n\n6. 文档写完开始编码阶段\n\n   * 再次抱怨老师没有有用的知识输出\n   * 分工变成了前后端分开，相对合理\n   * 组内分工结束三天后才和前端某同学商量页面分工，初步分了一下，开始写\n   * 中途逃课被逮住一次\n\n7. 前端我的部分完成\n\n   * 基本写完我的部分，老师第一次检查进度，发现后端除了基本的增删改查几乎没写，联系另一个前端同学O一直不回消息\n\n   * 尝试再次联系另一个前端同学O，不回\n\n   * 和组长L商量那个同学的情况，组长说把这部分工作分给了另外一个后端同学Z，他一个人写后端就行\n\n   * 与同学Z联系问他进度，他说还卡在登录注册.....\n\n   * 鉴于后端写得有些乱七八糟以及同学Z不会后端，于是说前端全部给我写好了，他们俩把后端写好就行\n\n   * 三天后同学O终于回消息说自己这几天发病了精神状态不太对，问啥时候截止，此时他的部分我已写一大半\n\n   * 无法判别是否真的生病，只能和朋友说“如果是真的我希望是假的，如果是假的我希望是真的”，理解生病但是不理解为什么不和大家说进度\n\n   * 和同学O说他不用写了我写就行，如下\n\n     <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101459911.png\" alt=\"image-20220910145932831\" style=\"zoom:50%;\" />\n\n   * 第三周周末前端几乎完成，与后端整合开始\n\n8. 开始与后端整合\n\n   * 几乎是我一个人的工作\n\n   * 后端非常多接口都没写\n\n   * 中途我去做了根管，，\n\n   * 开始整合\n\n     1. 后端没跨域处理\n\n        <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101502103.png\" alt=\"image-20220910150225047\" style=\"zoom:50%;\" />\n\n     2. 注册传不进参数，同学L说swagger测试没问题，我用的前端以及postman都有问题，换成swagger问题依然存在，遂以为是我电脑环境的问题，后来发现是代码的问题......\n\n        <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101504764.png\" alt=\"image-20220910150448708\" style=\"zoom:50%;\" />\n\n        <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101505485.png\" alt=\"image-20220910150533359\" style=\"zoom: 40%;\" />\n\n     3. 一个人合前后端没人帮忙的情况下多次催进度，，\n\n        <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101508483.png\" alt=\"image-20220910150811416\" style=\"zoom:50%;\" />\n\n     4. 后端改动后不列出具体改动哪里，一个所有的打包文件发过来。。\n\n        <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101508583.png\" alt=\"image-20220910150839534\" style=\"zoom:50%;\" />\n\n     5. 后端需改动让前端改一下\n\n        <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101510316.png\" alt=\"image-20220910151005239\" style=\"zoom:50%;\" />\n\n     6. 这个尼玛就是我的心情\n\n        <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101510737.png\" alt=\"image-20220910151032690\" style=\"zoom:50%;\" />\n\n     7. 第二次进度组长上讲台给老师展示\n\n        <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101511170.png\" alt=\"image-20220910151123121\" style=\"zoom:50%;\" />\n\n     8. 数据库表的连接删除有问题，哈哈非说swagger测试了没问题\n\n        <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101512189.png\" alt=\"image-20220910151236120\" style=\"zoom:50%;\" />\n\n        <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101515178.png\" alt=\"image-202209101515178\" style=\"zoom:50%;\" />\n\n     9. 不知道说什么，，，\n\n        <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101513046.png\" alt=\"image-20220910151316006\" style=\"zoom:50%;\" />\n\n        <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101513947.png\" alt=\"image-20220910151337864\" style=\"zoom:50%;\" />\n\n     10. 给出问题所在还是不同意，以为他理解了其实没理解\n\n         <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101519021.png\" alt=\"image-20220910151924924\" style=\"zoom:50%;\" />\n\n         <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101519841.png\" alt=\"image-20220910151924924\" style=\"zoom:50%;\" />\n\n         <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101521802.png\" alt=\"image-20220910152137721\" style=\"zoom:50%;\" />\n\n     11. 懂了过后说方案结果不改，我直接震惊了\n\n         <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101522502.png\" alt=\"image-20220910152235445\" style=\"zoom:50%;\" />\n\n     12. 接口“写了”不好测哈哈\n\n         <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101523191.png\" alt=\"image-20220910152307130\" style=\"zoom:50%;\" />\n\n         <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101523313.png\" alt=\"image-20220910152307130\" style=\"zoom:50%;\" />\n\n     13. 提出解决方案后问我怎么做，\n     \n         <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101525941.png\" alt=\"image-20220910152535868\" style=\"zoom:50%;\" />\n     \n     14. 接口传参有问题，说了不改，，\n     \n         <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101526899.png\" alt=\"image-20220910152632813\" style=\"zoom:50%;\" />\n     \n     15. 分页接口写得不对还非要写分页，，\n     \n         <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101527128.png\" alt=\"image-20220910152732057\" style=\"zoom:50%;\" />\n     \n     16. 答辩前一天还在大改，，\n     \n         <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101528552.png\" alt=\"image-20220910152822473\" style=\"zoom:50%;\" />\n     \n     17. 在我明确说过看板娘之类的元素不好看的情况下，在答辩前还是改了我的前端加上去了哈哈\n     \n         <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101529406.png\" alt=\"image-20220910152915364\" style=\"zoom:50%;\" />\n     \n     18. 答辩当天说电脑不行要用我的电脑\n     \n         <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101530799.png\" alt=\"image-20220910153018737\" style=\"zoom:50%;\" />\n     \n         他不肯呐哈哈\n     \n         <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101530970.png\" alt=\"image-20220910153045924\" style=\"zoom:50%;\" />\n     \n     19. 上午答辩结束后已经去食堂吃饭忽然给我说\n     \n         <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101531512.png\" alt=\"image-20220910153156461\" style=\"zoom:50%;\" />\n     \n     20. 觉得自己很幽默吗？\n     \n         <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101532546.png\" alt=\"image-20220910153229506\" style=\"zoom:50%;\" />\n     \n     21. 我说1点过去非得12：40，说要录视频，最后精彩的是什么朋友们，2点开始下午答辩，1：57视频还没录，视频也是我录的哈哈哈麻麻的\n     \n         <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101533275.png\" alt=\"image-20220910153352211\" style=\"zoom:50%;\" />\n     \n     22. 让我12：40过去，12：40教室没人，说没找到空的教室，可是我在的教室就是空的哈哈\n     \n         <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101534774.png\" alt=\"image-20220910153450721\" style=\"zoom:50%;\" />\n     \n     23. 哈哈结果就是改了我的前端\n     \n         <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202209101535611.png\" alt=\"image-20220910153536577\" style=\"zoom:50%;\" />\n\n9. 答辩过程\n\n   * 讲得稀烂，演示稀烂，改了我的前端这件事我是不可能能原谅的\n\n10. 答辩结束\n\n   * 希望这辈子都不会碰到，希望这辈子都不会再碰到这么烂的组。\n   * 结束后飞速退掉了两个小组群\n\n\n\n**写在最后：**\n\n并不是不能接受和成绩不好的同学组队，而是接受不了无法沟通以及摆烂的组员，他们可能挂科无所谓，可是我不能接受。舍友说得很对，烂的应该在一个队，这样大家的情绪都是一样的。而不是像我们组，只有我一个人在地狱。真是你觉得负重前行是因为有人在替你岁月静好。\n\n希望再也不会遇到烂组员！\n\n","tags":["studying","thoughts"],"categories":["Let's think","Life"]},{"title":"前端学习笔记","url":"/post/91ce7628.html","content":"\n## Before Reading\n\n1. 请点击左下方小框打开目录配合阅读\n2. 只有基础与大致的内容\n3. 大部分参考来自<a href=\"https://www.runoob.com\">菜鸟教程</a>\n4. 点击可见<a href=\"https://www.runoob.com/cssref/css-colornames.html\">颜色名称表</a>\n\n\n\n***\n\n\n\n[TOC]\n\n<!-- more -->\n\n## HTML\n\nHTML(Hypertext Makeup Language)，即超文本**标记**语言，主要负责网页内容的展示，大小写不敏感。\n\n### 标记\n\n   一般以<标签名>...</标签名>的形式成对出现，自结束标签无需结束符\n\n#### 常见的标签\n\n   * 文档声明[html5]：<!doctype html>放在顶端\n\n   * 网页根标签：`<html>...</html>`\n\n   * `<head>...</head>非用户可见，一般为告诉浏览器属性`\n\n     * head中的标题/浏览器头部标题：`<title>text</title>`\n\n     * HTML文档元数据：`<meta>`,可说明编码类型，描述(discription)，作者(author)等等\n\n       `<meta charset=\"utf-8\">`\n\n       `<meta name=\"author\" content=\"moo1\">`\n\n     * 链接：`<link>`，定义文档与外部资源的关系，空元素，只包含属性，常用于来链接样式表。\n\n       * 属性：\n\n         1. herf：被链接文档的位置\n         2. rel：当前文档与被链接文档之间的关系，<mark>必须</mark>\n         3. type：type 属性规定被链接文档/资源的 MIME 类型。只有当设置了 href 属性时，才能使用该属性。`<link>` 标签常用的 MIME 类型是 \"text/css\"，它规定样式表。\n\n         <a href=\"https://www.runoob.com/tags/tag-link.html\">更多与link属性相关可点击查看。</a>\n\n         \n\n* `<body>...</body>`用户可见，具体内容\n  \n* 标题：`<hn>text</hn>`,n=1~6\n  \n* 段落：`<p>text</p>`\n  \n* 超链接：`<a>text</a>`，一般与herf属性一起使用\n  \n  <a href=\"https://mooyi.xyz\">welcome to mooyi's channel!</a>\n  \n* 换行：`<br>`\n  \n* 粗体：`<b>text</b>`\n  \n     **Atten**:`<strong>text</strong>`也有加粗的效果，但是还表示重要呈现\n   \n* 按钮：`<button>text</button>`\n  \n  <button>text</button>\n  \n* 文档中的节：`<div>text</div>`\n  \n* 文本中的节：`<span>text</span>`\n  \n* 斜体：`<i>text</i>`\n  \n     **Atten**:`<em>text</em>`也有斜体效果，同样表示重要呈现\n   \n* 输入：`<input>`\n  \n* 高亮：`<mark>text</mark>`\n  \n  <mark>text</mark>\n  \n* 下标：`1<sub>text</sub>`\n  \n  1<sub>text</sub>\n  \n* 上标：`1<sup>text</sup>`\n  \n  1<sup>text</sup>\n  \n* 删除线：`<del>text</del>`\n  \n  <del>text</del>\n  \n* 插入/下划线：`<ins>text</ins>`\n  \n  <ins>text</ins>\n\n<a href=\" https://www.runoob.com/tags/ref-byfunc.html\">更多标签可点击查看。</a>\n\n\n\n### 标签属性\n\n  在开始标签中设置，属性是键值对结构(\"key\"=\"value\")\n\n#### 常见属性\n\n   * id(唯一)\n\n   * style:指定行内样式，多个样式以;分隔\n\n     `style=\"color:red;text-align:center\"`\n\n     <p style=\"color:red;text-align:center\">\n         style-showing.\n     </p>\n\n   * title：额外信息/工具条\n\n     `<p><ins title=\"格外信息\">move</ins> on this</p>`\n\n     <p><ins title=\"格外信息\">move</ins> on this</p>\n\n<a href=\"https://www.runoob.com/tags/ref-standardattributes.html\">更多属性可点击查看。</a>\n\n\n\n### 注释\n\n`<!--this is unshown.-->`\n\n\n\n### HTML事件\n\n事件可以触发浏览器行为，与JS联合使用。\n\n表示：`event=\"script()\"`\n\n#### 窗口事件属性(Window Event Attributes)\n\n窗口触发，适用于`<body>`标签\n\n* onresize：调整窗口大小时运行脚本\n\n  `<body onresize=\"Function()\">`\n\n* 文档触发，窗口失焦...\n\n\n\n#### 表单事件(Form Events)\n\n表单中触发，HTML元素需在form表单内。\n\n\n\n#### 键盘事件(Mouse Events)\n\n* onkeydown：按下键盘\n* onkeypress：按下并松开\n* onkeyup：松开按键\n\n\n\n#### 鼠标事件(Mouse Events)\n\n* onclick：单击\n* ondblclick：双击\n* ondrag：拖动元素\n\n...\n\n\n\n#### 多媒体事件(Media Events)\n\n通过视频（videos），图像（images）或者音频（audio） 触发该事件，多应用于 HTML 媒体元素比如 `<audio>, <embed>, <img>, <object>, 和<video>`:\n\n\n\n#### 其他事件\n\n\n\n<a href=\"https://www.runoob.com/tags/ref-eventattributes.html\">更多事件可点击查看。</a>\n\n\n\n其余HTML相关内容可参考https://www.runoob.com/html/html-tutorial.html\n\n\n\n***\n\n\n\n## CSS\n\nCSS(Cascading Style Sheets)，主要负责网页布局，描述HTML/XML的呈现，即其如何被渲染。\n\n```css\np{\n\tfont-size: 20px;\n\tcolor:red;\n}\n```\n\n&lt;<span style='background-color:red'>p</span>&gt;text&lt;/p&gt;\n\np:选择器\n\nfont-size/color:属性，冒号后为其值\n\n大括号括着的为声明，声明以;结束\n\n\n\n### 选择器\n\n#### id选择器\n\n  以#定义，不以数字开头(避免在Mozilla/Firefox不起作用)\n\n  eg.: <mark>**#test**</mark>{\n\n  ​\ttext-align:center;\n\n  ​\tcolor:red;\n\n  }\n\n  &lt;p <mark>**id=\"test\"**</mark>&gt;text&lt;/p&gt;\n\n#### class选择器\n\n  以.显示，多个用空格区分，类名第一个字符非数字\n\n  eg.:\n\n  <span style=\"background-color:#7FFFD4\">**.center**</span>{\n\n  text-align:center;\n\n  }\n\n  &lt;p <span style=\"background-color:#7FFFD4\">**class=\"center\"**</span>&gt;text&lt;/p&gt;\n\n注释：`/*text*/`\n\n\n\n### 组合选择符\n\n#### 后代选择器\n\n选取某元素的后代元素，以空格` ` 分离。\n\n```html\n<style>\ndiv p\n{\n\tbackground-color:yellow;\n}\n</style>\n\n<div>\n<p>段落 1。 在 div 中。</p>\n<p>段落 2。 在 div 中。</p>\n</div>\n\n<p>段落 3。不在 div 中。</p>\n<p>段落 4。不在 div 中。</p>\n```\n\n<img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202207311311428.png\" alt=\"image-20220731131103323\" style=\"zoom:67%;\" />\n\n#### 子元素选择器\n\n只能选择作为某元素<span style=\"background-color:#E0FFFF\">直接/一级子元素的元素</span>，大于符号`>`分隔。\n\n\n```html\n<style>\ndiv>p\n{\n\tbackground-color:yellow;\n}\n</style>\n\n<h1>Welcome to My Homepage</h1>\n<div>\n\t<h2>My name is Donald</h2>\n\t<p>I live in Duckburg.</p>//highlight\n</div>\n\n<div>\n\t<span><p>I will not be styled.</p></span>//no highlight with the first child \"span\"\n    <p><span>I will be styled.</span></p>//highlight because \"p\" is the first child\n</div>\n\n<p>My best friend is Mickey.</p>\n```\n\n<img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202207311322609.png\" alt=\"image-20220731132236565\" style=\"zoom: 50%;\" />\n\n#### 相邻兄弟选择器\n\n选择<span style=\"background-color:#E0FFFF\">**紧接**在另一元素后的元素，且二者有相同父元素</span>，用`+`分隔。\n\n```html\n<style>\ndiv+p\n{\n\tbackground-color:yellow;\n}\n</style>\n\n<div>\n<h2>DIV 内部标题</h2>\n<p>DIV 内部段落。</p>\n</div>\n\n<p>DIV 之后的第一个 P 元素。</p>//adjacent to the \"div\"\n\n<p>DIV 之后的第二个 P 元素。</p>\n```\n\n<img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202207311326422.png\" alt=\"image-20220731132642385\" style=\"zoom:67%;\" />\n\n\n\n#### 后续兄弟元素\n\n后续兄弟选择器选取<span style=\"background-color:#E0FFFF\">所有指定元素**之后**的相邻兄弟元素</span>。用`~`隔开。\n\n```html\n<style>\ndiv~p\n{\n\tbackground-color:yellow;\n}\n</style>\n\n<p>之前段落，不会添加背景颜色。</p>\n<div>\n<p>段落 1。 在 div 中。</p>\n<p>段落 2。 在 div 中。</p>\n</div>\n\n<p>段落 3。不在 div 中。</p>\n<p>段落 4。不在 div 中。</p>\n```\n\n<img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202207311331016.png\" alt=\"image-20220731133141976\" style=\"zoom: 67%;\" />\n\n\n\n\n\n\n### 插入样式表\n\n#### 外部样式表(external style sheet)\n\n  一般用于*同一样式需用于很多页面*，通过mystyle.css文件改变站点整体样式【页面使用`<link>`标签链接到样式表，该标签位于文档头部`<head>`中】\n\n  `<link rel=\"stylesheet\" href=\"mystyle.css\">`\n\n#### 内部样式表(internal style sheet)\n\n  一般用于*单个文件*，利用`<style>`标签在头部文件内部定义。\n\n  <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202207291021544.png\" alt=\"image-20220729102140460\" style=\"zoom: 80%;\" />\n\n#### 内联样式(inline style)\n`<p style=\"color:sienna;margin-left:20px\">text</p>`\n\n<p style=\"color:sienna;margin-left:20px\">text</p>\n\n**Atten:<span style=\"background-color:#ADFF2F\">多重样式优先级</span>**\n内联>内部>外部>默认\n\n\n\n### 背景\n\n- background-color\n- background-image\n- background-repeat：水平或垂直方向平铺或不平铺(repeat-x/repeat-y/no-repeat)\n- background-attachment：是否固定/滚动\n- background-position：起始位置\n\n背景可简写属性，属性顺序如上顺序，属性可不全部使用。\n\n`body {background:#ffffff url('img_tree.png') no-repeat right top;}`\n\n\n\n### 对齐\n\n* 元素居中对齐\n\n使用`margin: auto`\n\n图片居中对其需放入块元素中\n\n\n\n* 文本居中对齐\n\n`text-align: center`\n\n\n\n* 左右对齐-定位\n\n`position:absolute`\n\n注释：绝对定位元素会被从正常流中删除，并且能够交叠元素。\n\n**Atten:** 当使用 **position** 来对齐元素时, 通常`<body>`元素会设置 **margin** 和 **padding** 。 这样可以避免在不同的浏览器中出现可见的差异。\n\n\n\n* 左右对齐-float\n\n`float:left/right`\n\n**Atten**：如果子元素的高度大于父元素，且子元素设置了浮动，那么子元素将溢出，这时候你可以使用 \"***clearfix***(清除浮动)\" 来解决该问题。可以在父元素上加`overflow:auto`来解决子元素溢出。\n\n\n\n* 垂直居中-padding\n\n```css\n.center {\n    padding: 70px 0;//水平居中\n    border: 3px solid green;\n    text-align: center;//垂直居中\n}\n```\n\n\n\n* 垂直居中-line-height\n\n```css\n.center {\n    line-height: 200px;\n    height: 200px;\n    border: 3px solid green;\n    text-align: center;\n}\n \n/* 如果文本有多行，添加以下代码: */\n.center p {\n    line-height: 1.5;\n    display: inline-block;\n    vertical-align: middle;\n}\n```\n\n\n\n* 垂直居中-position&transform\n\n```css\n.center { \n    height: 200px;\n    position: relative;\n    border: 3px solid green; \n}\n \n.center p {\n    margin: 0;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n}\n```\n\n\n\n### 伪类(Pseudo-classes)&伪元素\n\n#### 伪类\n\n伪类语法：`selector:pseudo-class {property:value;}`\n\nCSS类使用伪类：`selector.class:pseudo-class {property:value;}`\n\n#### 伪元素\n\n语法：`selector:pseudo-element {property:value;}`\n\nCSS类使用伪元素：`selector.class:pseudo-element {property:value;}`\n\n\n\n<a href=\"https://www.runoob.com/css/css-tutorial.html\">其余相关内容请点击查看。</a>\n\n\n\n\n\n***\n\n\n\n\n\n## JavaScript\n\nJavaScript是一种脚本语言，控制了网页的行为，插入HTML页面后，由浏览器执行。\n\n浏览器逐行读取并执行代码(不是先全部编译再执行)。\n\n\n\n### 使用\n\n* 在HTML文件页中使用`<script>...</script>`标签。\n\n  Atten:一般放在head中或页面底部(body)\n\n* HTML文件可使用外部的.js文件，利用script标签的<span style=\"color:red\">src</span>属性\n\n  `<script src=\"myScript.js\">...</script>`\n\n使用时，为`事件=函数名()`.\n\n\n\n### 输出/显示数据\n\n* window.alert()弹出警告\n```html\n<script>\n\twindow.alert(2);\n\t</script>\n```\n\n* document.write()将内容写入HTML文档\n\n```html\n  <script>\n  document.write(\"11\");\n  </script>\n```\n\n\n  **Atten**:仅向文档输出写内容，<span style=\"background-color:#E0FFFF\">若在文档加载完成后执行，整个页面将被覆盖</span>。\n\n  <span style=\"background-color:#E0FFFF\">Example</span>\n\n```html\n\t<button onclick=\"test()\">test1</button>\n\t<script>\n\t document.write(\"document1\");\n\t \tfunction test(){\n\t \tdocument.write(\"refreshing\");\n\t \t}\n\t </script>\n```\n\n   result:<img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202207312149397.png\" alt=\"image-20220731212404112\" style=\"zoom:67%;\" />\n\n   After clicking the botton:<img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202207312150251.png\" alt=\"image-20220731213114137\" style=\"zoom:80%;\" />\n\n\n* innerHTML写入到HTML文档中\n\n```html\n   <script>\n   document.getElementById(\"id1\").innerHTML=\"new text\";\n   </script>\n```\n\n* console.log()写入到控制台\n\n```html\n   <script>\n   console.log(2);\n   </script>\n```\n\n   一般为利用浏览器进行调试。\n\n   \n\n### 语法\n\n#### 字面量(固定值)\n\n* 数字(Number)：整数/小数`3.14`\n\n* 字符串(String)：单引号/双引号`'text'`/`\"text\"`\n\n  * 可使用索引位置访问单个字符\n  * 字符串中可含引号，不能与字符串的相同/使用转义字符`\\'`or`\\\"`以使用引号\n  * 可使用.length计算长度\n  * 可使用new关键字将字符串定义为对象\n\n* 表达式：`1+1`\n\n* 数组(Array)：`[1,2,3]`/`['apple','orange']`\n\n* 对象(Object)：`{key1:\"value1\",key2:\"value2\"}`，可跨行定义\n\n  访问对象属性：\n\n  ```js\n  var person={\n      name:\"Lee\",\n      age:\"22\",\n      information:function(){\n      return \"name:\"+this.name+\" \"+\"age:\"+this.age;\n  }};\n  //access attributes1\n  person.name;\n  //access attributes2\n  person[\"name\"];\n  //access function\n  var infor=person.information();//without(),the strings of \"information\" will be displayed\n  ```\n\n  **Atten**:<span style=\"background-color:#FFFACD\">数组索引为数字，对象索引为名字(key/name)</span>\n\n* 函数(Function)：`function myFunction(){}`\n\n\n\n#### 数据类型\n\n<img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202207312329738.png\" alt=\"image-20220731232911606\" style=\"zoom: 67%;\" />\n\n\n\n#### 变量\n\n使用关键字<span style=\"color:red\">var</span>定义变量，`var a=1;`\n\n* 变量名使用驼峰命名法，大小写敏感。\n\n* 变量声明`var name;`,此时name的值为undefined\n\n* 重新声明变量，其值不会丢失\n\n* JS拥有动态类型，相同变量可作不同类型\n\n* const关键字定义常量，声明时初始化`const x=10;`，作用域与let相似\n\n  <mark>Atten</mark>：const定义的并不是严格意义上的常量，它定义了一个常量引用一个值。使用 const 定义的对象或者数组，其实是可变(<span style=\"color:red\">可修改/增加元素，不可重新赋值</span>)的。\n\n  ```js\n  const person={name:\"Lee\",age:\"22\"};//常量对象\n  person.name=\"Ham\";//修改属性\n  person.location=\"xxx\";//添加属性\n  //不可对常量对象重新赋值\n  //person={name:\"Ham\",age:\"22\"} //wrong\n  ```\n\n  可以使用Object.freeze()来冻结变量放置修改。\n\n##### 变量作用域\n\n* 函数体外声明的变量为全局变量，函数内声明的变量为局部变量(var)\n\n* <span style=\"color:green\">在块中声明var变量，其在块外依然可被访问</span>\n\n  <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202207312223668.png\" alt=\"image-20220731222319625\" style=\"zoom: 80%;\" />\n\n* 使用<span style=\"background-color:#B4EEB4\">let</span>关键字可实现只在块内有效\n\n  <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202207312225564.png\" alt=\"image-20220731222514523\" style=\"zoom:80%;\" />\n\n* 重新定义变量\n\n  * var：可在任意地方修改,<img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202207312231711.png\" alt=\"image-20220731223151672\" style=\"zoom:67%;\" />\n  * let：<img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202207312231209.png\" alt=\"image-20220731223135155\" style=\"zoom:67%;\" />\n  * 相同作用域/块级作用域中，不能用let关键字重置var/let声明的变量\n  * 相同作用域/块级作用域中，不能用 var关键字重置let声明的变量\n  * 相同作用域/块级作用域中，不能用 const关键字重置var/let/const声明的变量\n\n* 使用var声明的全局变量<span style=\"background-color:#FFC1C1\">属于window对象</span>.\n\n* 使用let声明的全局变量<span style=\"background-color:#FFC1C1\">不属于window对象</span>.\n\n* <b><span style=\"color: #FF8247\">var变量可以先使用再声明</span>(作为全局变量，可删除,<span style=\"background-color:#4682B4;color:white\">严格模式下不允许</span>)，let变量必须声明才能使用。</b>\n\n  * 严格模式(use strict)\n\n    >在脚本或函数头部添加`\"use strict\";`表达式来声明\n    >\n    >* 不允许使用未声明变量\n    >\n    >* 不允许删除变量或对象\n    >\n    >* 不允许删除函数\n    >\n    >* 不允许变量重名\n    >\n    >* 不允许使用八进制\n    >\n    >* 不允许使用转义字符`\\`\n    >\n    >* 不允许对只读属性赋值(writable:false)\n    >\n    >* 不允许对使用getter方法读取的属性赋值\n    >\n    >  ```js\n    >  \"use strict\";\n    >  var obj = {get x() {return 0} };\n    >  \n    >  obj.x = 3.14;            // 报错\n    >  ```\n    >\n    >* 不允许删除不允许删除的属性\n    >\n    >* 变量名不能使用`\"eval\"/\"arguments\"`字符串\n    >\n    >* 不允许使用如下语句\n    >\n    >  ```js\n    >  \"use strict\";\n    >  with (Math){x = cos(2)}; // 报错\n    >  ```\n    >\n    >* 由于一些安全原因，在作用域 eval() 创建的变量不能被调用\n    >\n    >  ```js\n    >  \"use strict\";\n    >  eval (\"var x = 2\");\n    >  alert (x);               // 报错\n    >  ```\n    >\n    >* 禁止this关键字指向全局对象：严格模式下this为undefined\n    >\n    >函数内部使用作用域为函数内部\n\n\n\n##### 程序块作用域\n\n在每个代码块中 JavaScript 不会创建一个新的作用域，一般各个代码块的作用域都是全局的。\n\n  ```js\nfor (var i = 0; i < 10; i++) {\n    // some code\n}\nreturn i;//i=10, not undefined\n  ```\n\n \n\n##### 声明提升\n\n> * 函数及变量的<span style=\"background-color:#EEE0E5\">声明都将被提升到函数的最顶部</span>，即声明位于任意位置都等同与在函数顶部\n> * <span style=\"background-color:#E0EEE0\">初始化不会提升</span>，即初始化后位置确定\n> * 一般在每个作用域前声明所有变量\n\n\n\n\n\n#### 语句\n\n* 语句自动忽略多余空格\n\n* 语句以，分隔\n\n* 可在文本字符串中使用反斜杠对代码换行\n\n  ```js\n  document.write(\"hello\\\n  world!\");\n  ```\n\n* 注释为`//`与`/*...*/`\n\n* return语句自动看作加分号的语句（代码结束[默认为最后一句]）\n\n##### 比较运算符\n\n![image-20220731231259574](https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202207312312796.png)\n\n* 普通比较\"=\\=\"忽略数据类型，严格比较\"===\"同时检查值与类型\n* switch语句中case的比较为严格比较(===)\n\n\n\n##### For/In循环\n\n遍历对象属性\n\n  ```js\nvar infor;\nvar person={name:\"Ham\",age:22};\nfor(x in person){//x为属性名\n    infor=person[x]+\" \";\n}\n//infor=Ham 22 ;\n  ```\n\n\n\n##### Typeof/null/undefined\n\n* typeof可用于检测变量的数据类型，`typeof  'Ham'`/`typeof 3.14\t`\n\n* NaN的数据类型为number\n\n* Atten:数组时对象的特殊类型，所以`typeof Array/Date`返回对象\n\n  * constructor属性返回所有JS变量的<mark>构造函数</mark>\n\n  * 通过constructor判断类型：检验返回值是否包含相应字符串\n\n\n  ```js\nfunction isArray(arr){\n    return arr.constructor.toString().indexOf(\"Array\")>-1;\n}\n  ```\n\n\n\n\n* null 表示空对象引用，`typeof null`返回对象\n\n* 可以利用null来清空对象\n\n* undefined表示未设置值的变量，`typeof 未设置值的变量`返回undefined\n\n* 可以利用undefined来清空变量\n\n* <span style=\"color:orange\"> null== undefined //true</span>\n\n  <span style=\"color:orange\">  null===undefined //false </span>\n\n\n\n##### 类型转换\n\n* 数字->字符串\n\n  * String(number) `String(123)`\n  * Number.toString() `(123).toString()`\n\n* 布尔值->字符串\n\n  * String(false)\n  * false.toString()\n  * <a href=\"https://www.runoob.com/jsref/jsref-obj-number.html\">更多请参考</a>\n\n* 日期->字符串\n\n  * String(new Date())\n  * Date.toString() `obj.toString()`\n  * <a href=\"https://www.runoob.com/jsref/jsref-obj-date.html\">更多请参考</a>\n\n* 字符串->数字\n\n  * Number(\"3.00\")//3.00\n\n    Number(\"isd\")//NaN：非数字值\n\n  * parseFloat()\n\n  * parseInt()\n\n* 一元运算符+：将变量转换为数字\n\n\n  ````js\n  var a=\"1\";\n  var b+=a;//b是一个数字1\n  var c=\"hdai\";\n  var d+=c;//d为数字，值为NaN\n  ````\n\n\n\n\n* 日期->数字\n\n  * Number(new Date())\n  * Date.getTime()\n\n* 自动转换\n\n  <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202207312347452.png\" alt=\"image-20220731234708405\" style=\"zoom:80%;\" />\n\n* 自动转换为字符串\n\n  尝试输出一个对象或一个变量时 JavaScript 会自动调用变量的 toString() 方法\n\n<a href=\"https://www.runoob.com/js/js-type-conversion.html\">更多请查看</a>\n\n\n\n### 正则表达式(Regular Expression/regex/regexp/RE)\n\n* 正则表达式是由一个字符序列形成的搜索模式。\n\n* 当你在文本中搜索数据时，你可以用搜索模式来描述你要查询的内容。\n\n* 正则表达式可以是一个简单的字符，或一个更复杂的模式。\n\n* 正则表达式可用于所有文本搜索和文本替换的操作。\n\n#### 语法\n\n`/正则表达式主体/修饰符(可选)`\n\n主体用于检索，不区分大小写\n\n* 修饰符\n  * i： 执行对大小写不敏感的匹配。\n  * g：执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。\n  * m：执行多行匹配。\n\n#### 使用字符串方法\n\n* search()\n\n  检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。可使用字符串作参数（自动转化为正则表达式）。\n\n\n  ```js\n  var str=\"HelloWorld\";\n  var n=str.search(/World/i);//n=5\n  var m=str.search(\"World\");//字符串参数自动转化为正则表达式,m=5\n  ```\n\n\n\n* replace()\n\n  使用正则表达式且不区分大小写将字符串中的A替换为B，可使用字符串作参数\n\n\n  ```js\n  var str=\"HelloWorld\";\n  var text=str.replace(/world/i,\"JS\");//text=\"HelloJS\"\n  var text1=str.replace(\"World\",\"JS\");\n  ```\n\n\n\n#### 正则表达式模式\n\n* 方括号用于查找某个范围内的字符\n\n  <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202208010007126.png\" alt=\"image-20220801000731016\" style=\"zoom:90%;\" />\n\n* 元字符拥有特殊含义\n\n  <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202208010008921.png\" alt=\"image-20220801000804874\" style=\"zoom:80%;\" />\n\n* 量词\n\n  <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202208010008243.png\" alt=\"image-20220801000823200\" style=\"zoom:90%;\" />\n\n\n\n#### RegExp对象\n\n一个预定义了属性和方法的正则表达式对象。\n\n##### test()\n\n用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。\n\n\n  ``` js\n/e/.test(\"hello\");//true\n  ```\n\n##### exec()\n\n用于检索字符串中的正则表达式的匹配。该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。\n\n  ```js\n/e/.exec(\"hello\");//输出e\n  ```\n\n\n\n<a href=\"https://www.runoob.com/jsref/jsref-obj-regexp.html\">更多有关RegExp请参考</a>\n\n\n\n### 错误处理：throw, try, catch\n\n  ```js\ntry{\n    ...//exception\n    //can throw exception  defined by the author\n   throw exception //exception can be string/number/logical value/object\n}catch(err){\n    ...//catch exception and handle\n}finally{\n    ...//execute all the time\n}\n  ```\n\n\n\n### 调试\n\n断点/debugger关键字：停止执行JS代码，调用调试函数\n\n\n\n### 验证API\n\n#### 约束验证DOM（Document Object Model）方法\n\n* checkValidity()：如果 input 元素中的数据是合法的返回 true，否则返回 false\n\n  ```html\n  <input id=\"id1\" type=\"number\" min=\"100\" max=\"300\" required>\n  <button onclick=\"myFunction()\">验证</button>\n   \n  <p id=\"demo\"></p>\n   \n  <script>\n  function myFunction() {\n      var inpObj = document.getElementById(\"id1\");\n      if (inpObj.checkValidity() == false) {//输入值不在100~300之间\n          document.getElementById(\"demo\").innerHTML = inpObj.validationMessage;\n      }\n  }\n  </script>\n  ```\n\n  \n\n* setCustomValidity()：设置 input 元素的 validationMessage 属性，用于自定义错误提示信息的方法。\n\n  使用 setCustomValidity 设置了自定义提示后，validity.customError 就会变成 true，checkValidity 总是会返回 false。如果要重新判断需要取消自定义提示，方式如下：\n\n  ```js\n  //使用前取消自定义提示方式，否则下次checkValidity总是false\n  setCustomValidity('')\n  setCustomValidity(null) \n  setCustomValidity(undefined)\n  ...//check and set...\n  ```\n\n\n\n#### 约束验证DOM属性\n\n* validity：布尔属性值，返回 input 输入值是否合法\n\n  <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202208011500025.png\" alt=\"image-20220801150057861\" style=\"zoom:67%;\" align=\"left\" />\n\n  \n\n* validationMessage：浏览器错误提示信息\n\n* willValidate：指定 input 是否需要验证\n\n\n\n\n\n### JSON\n\nJSON(JavaScript Object Notation)，使用JS语法，但是独立于语言，JSON是轻量级的文本数据交换格式。\n\n\n\n#### 语法规则\n\n> * 数据为键值对(`\"key\":value`)，key必须是字符串，必须在双引号中\n>\n>   > 访问对象值\n>   >\n>   > * obj.key\n>   > * obj[\"key\"]\n>\n> * 数据由`,`分隔\n>\n> * 大括号`{}`保存对象，方括号`[]`保存数组\n\n\n\n#### JSON字符串转换为JS对象\n\n使用<mark>JSON.parse(**text**,reviver)</mark>将接受的数据(字符串)转化为JS对象\n\n* text：必需，一个有效的JSON字符串\n* reviver：可选，一个转换结果的函数， 将为对象的每个成员调用此函数。\n* <a href=\"https://c.runoob.com/front-end/53/\">检验JSON格式是否合法</a>\n\n\n\n##### Atten\n\n1. JSON不能存储Date对象，如果需要存储 Date 对象，需要将其转换为字符串。之后再将字符串转换为 Date 对象。\n\n ```js\nvar text = '{ \"name\":\"Google\", \"initDate\":\"2011-11-11\", \"site\":\"www.google.com\"}';\nvar obj = JSON.parse(text);\nobj.initDate = new Date(obj.initDate);\n ```\n\n​       可以使用reviver参数，一个转换结果的函数，对象的每个成员调用此函数。\n\n ```js\nvar text = '{ \"name\":\"Google\", \"initDate\":\"2011-11-11\", \"site\":\"www.google.com\"}';\nvar obj = JSON.parse(text, function (key, value) {\n    if (key == \"initDate\") {\n        return new Date(value);\n    } else {\n        return value;\n}});\n ```\n\n2. JSON 不允许包含函数，但以将函数作为字符串存储，之后再将字符串转换为函数。\n\n   不建议使用函数\n\n\n\n#### JS对象转换为字符串\n\n使用<mark>JSON.stringify(**value**,replacer,space)</mark>将 JavaScript 对象转换为字符串。\n\n* value:必须， 要转换的 JavaScript 值（通常为对象或数组）。\n\n* replacer:可选。用于转换结果的函数或数组。\n\n  如果 replacer 为函数，则 JSON.stringify 将调用该函数，并传入每个成员的键和值。使用返回值而不是原始值。如果此函数返回 undefined，则排除成员。根对象的键是一个空字符串：\"\"。\n\n  如果 replacer 是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。当 value 参数也为数组时，将忽略 replacer 数组。\n\n* space:可选，文本添加缩进、空格和换行符，如果 space 是一个数字，则返回值文本在每个级别缩进指定数目的空格，如果 space 大于 10，则文本缩进 10 个空格。space 也可以使用非数字，如：\\t。\n\n\n\n##### Atten\n\n1. JSON 不能存储 Date 对象。JSON.stringify() 会将所有日期转换为字符串。\n2. JSON 不允许包含函数，JSON.stringify() 会删除 JavaScript 对象的函数，包括 key 和 value。\n\n\n\n\n\n### javascript:void(0) \n\nvoid:指定要计算一个表达式但是不返回值。\n\n> void func()\n>\n> javascript: void func()\n\n> void(func())\n>\n> javasript: void(func())\n\n```html\n<a href=\"javascript:void(0)\">单击此处什么也不会发生</a>\n```\n\n<a href=\"javascript:void(0)\">单击此处什么也不会发生</a>\n\n\n\n```html\n<p>点击以下链接查看结果：</p>\n<a href=\"javascript:void(alert('Warning!!!'))\">点我!</a>\n```\n\n<p>点击以下链接查看结果：</p> <a href=\"javascript:void(alert('Warning!!!'))\">点我!</a>\n\n\n\n#### href=\"#\"与href=\"javascript:void(0)\"的区别\n\n**#** 包含了一个位置信息，默认的锚是**#top** 也就是网页的上端。\n\n而javascript:void(0), 仅仅表示一个死链接。\n\n在页面很长的时候会使用 **#** 来定位页面的具体位置，格式为：**# + id**。\n\n如果你要定义一个死链接请使用 javascript:void(0) 。\n\n```html\n<a href=\"javascript:void(0);\">点我没有反应的!</a>\n<a href=\"#pos\">点我定位到指定位置!</a>\n<br>\n...\n<br>\n<p id=\"pos\">尾部定位点</p>\n```\n\n<a href=\"javascript:void(0);\">点我没有反应的!</a> <a href=\"#pos\">点我定位到指定位置!</a> <br> ... <br> <p id=\"pos\">尾部定位点</p>\n\n\n\n<a herg=\"https://www.runoob.com/js\">更多JavaScript内容可参考</a>\n\n\n\n## ES6\n\nES6(ECMAScript 6.0)为js的一种标准\n\n* Babel转码器可以将ES6代码转为ES6\n\n  Babel的配置文件<span style=\"color:red\">.babelrc</span>存放在项目的根目录，使用前需先配置\n\n  ```\n  {\n  \"presets\": [//设定转码规则\n   \"@babel/env\",\n   \"@babel/preset-react\"\n  ],\n  \"plugins\": []\n  }\n  ```\n\n* 命令行转码\n\n  ```\n  # 转码结果输出到标准输出\n  $ npx babel example.js\n  \n  # 转码结果写入一个文件\n  # --out-file 或 -o 参数指定输出文件\n  $ npx babel example.js --out-file compiled.js\n  # 或者\n  $ npx babel example.js -o compiled.js\n  \n  # 整个目录转码\n  # --out-dir 或 -d 参数指定输出目录\n  $ npx babel src --out-dir lib\n  # 或者\n  $ npx babel src -d lib\n  \n  # -s 参数生成source map文件\n  $ npx babel src -d lib -s\n  ```\n\n* babel-node 支持直接运行ES6代码\n\n","tags":["studying","front-end","coding"],"categories":["Learning","front-end"]},{"title":"不同年纪对应的音乐喜爱度变化","url":"/post/7b89dc1f.html","content":"\n\n\n随着年纪的增加，对不同音乐的喜好程度有了很大变化。\n\n <!-- more -->\n\n## 听歌软件的使用\n\n  最开始用的是咪咕音乐，后面开始用酷我音乐，然后开始用酷狗音乐，过渡到QQ音乐，网易云音乐，Apple Music以及现在用得较多的Spotify。\n\n\n\n## 小学期间\n\n  应该算是到了五年纪才有了自己找歌听的意识，在此之前都是被动地接受别人所放的歌曲。自己找歌听听得最多的是什么呢？徐良、许嵩、汪苏泷，也就是现在的所谓的童年”三巨头“。三人比较的话听得最多的应该是徐良，当时非常痴迷他和孙雨幽的合唱。\n\n《情话》这张专的好多歌我都还会唱，前段时间宿舍放歌放童年回忆歌曲，放到他们的歌我还能完整唱出来，不得不说确实算是刻在了我的脑子中。\n\n  其二就是许嵩，听许嵩其实应该算是受到一个发小的影响，当时没有什么自己找歌听的概念，一般是看到别人做什么就开始跟着听，但是好像几乎全是有关感情的歌，为什么小学生喜欢听这个？\n\n  汪苏泷其实好像就听了一两首，记忆最深的是小星星，现在也还会唱。\n\n  因为当时比较喜欢宋茜还听了挺多fx的歌来着，现在连歌名是什么都忘记了。\n\n\n\n## 初中\n\n  刚进入初中最开始其实还是保留小学的审美，后面因为主流审美的变化以及接触到了不同的同学才开始有所变化。\n\n  受湖南卫视我是歌手的影响，其实听到了很多算还不错的歌，刚刚去重新登录了酷我的账号，发现列表里几乎都是我是歌手里的歌以及一些电影主题曲。\n\n  受身边好朋友以及当时主流追星的影响，听了当时的TFBOYS的几乎全部歌曲，后面开始追韩国男团女团，听了当时的BTS以及GOT7的很多歌，也听了几首Bigbang的，现在几乎全忘了。\n\n  受身边一个朋友的影响开始听英文歌曲，听的第一个歌手应该是Taylor Swift，因为当时朋友很喜欢她。后面比较喜欢欧美音乐，开始了自己探索，大量听欧美歌曲，听b榜的歌曲，当时非常喜欢断眉，那个时期他发行的所有单曲都会唱。也很喜欢霉霉，不过好像只听了部分，最喜欢的是1989这张专，还记得当时QQ音乐这张专要付费，我还买了。\n\n\n\n## 高中\n\n  高中其实是初中的延续以及自己探索的延续。保留了听欧美的耳朵，不断听欧美流行歌曲，逐渐从断眉转变到喜欢萌德(Shawn Mendes)，后面觉得他从阳光大男孩转变到油腻大叔了以及出的专奇奇怪怪就放弃了(说的就是你senorita).但是还是一直在听欧美流行。\n\n  逐渐找到自己喜欢的歌曲的样子，开始听country music以及一些杂七杂八不同语言的歌曲。\n\n  过渡到后面非常喜欢看歌舞相关电影，开始听电影插曲，列表几乎全是pitch perfect 1-3以及High School Musical 1-3(歌舞青春)相关歌曲。偶尔穿插一切华语歌曲。\n\n  找到自己喜欢的电影的类型——歌舞剧，从现在来看也就是musical的电影拍摄版，开始大量看电影以及听里面的曲子，Moulin Rouge(红磨坊)，The Greatest Showman(马戏之王)，以及其他很有名的音乐剧的电影出品版。\n\n  一般而言是电影带动了我的曲库，有几个相反的算是：\n\n1. Try - Asher Monroe，真的太好听，因为这首歌去看的Fame\n2. Way back into love - Haley Bennett&Hugh Grant，非常非常喜欢电影demo版，真的很甜，所以去看了Music and Lyrics(K歌情人)\n\n  真的非常感谢声入人心这个节目，真的明白与找到了心中所爱，开始真正看音乐剧，第一部剧应该是Rent，其实应该也是Seasons of love吸引我去看的这部剧，真的入股不亏！\n\n\n\n## 大学\n\n  延续了高中的音乐剧，时间、资源充足所以较大量看剧，歌单几乎全是宽街原声。\n\n  大一考试周狠狠emo开始听五月天，也开始从网易云过渡到QQ音乐和Spotify，直到现在。\n\n\n\n## Some thoughts\n\n* 音乐真的是很私人的东西，每个人的口味都不太相同，献上我给朋友推荐音乐剧的图。\n\n  <img src=\"https://raw.githubusercontent.com/Mooyi646/ImageSaver/main/202207271017461.jpg\" alt=\"img\" style=\"zoom: 50%;\" />\n\n* 所有音乐都不分高低贵贱，自己喜欢即可。\n\n* 音乐口味的变化真的很神奇，现在去听我高一的歌单，我甚至会生出”我当时怎么去听这首歌并把它加入我的歌单“的想法。\n\n\n\n希望所有人都能找到自己喜欢的音乐！;-)","tags":["thoughts","Music"],"categories":["Let's think","Music"]},{"title":"关于拖延以及失去动力","url":"/post/72693323.html","content":"\n  这是从大二上一直到这学期期末周末尾都给自己定下的目标，没有想过现在才实现，也没有想过现在居然实现了。\n\n <!-- more -->\n\n  上大学以来一直都是行动力底下。高中的自己还能夸夸自己说“我觉得我的自制力还算不错啊”，到大学过后，从不敢说出这话了。\n\n  两年了，说什么事情也没做成的话，倒也是给自己的人生转了个弯。从工商管理大类到了如今的软工，你说没付出努力，别人说你骗谁呢，说我真的努力了啊，我说这是骗自己啊。\n\n  经常会想到底是什么让我失去了动力，亦或者说是向上的精神与对等的行动。我不知道。高中真的算是过得最快乐的三年的吧，中考的幸运延续，使得高中初始就算站在了还不错的起点，然后一直保持，偶尔徘徊，偶尔向上，总体都还算不错，为什么大学就截然不同了呢？或许是我没有从一开始就在相对的高处吧，我又怎么能够站得到高处呢？\n\n  总归是絮絮叨叨，实力与行动配不上自己的“野心”，确实是“卷也卷不赢，摆也不敢摆”。","tags":["thoughts","doer","procrastination"],"categories":["Let's think","Life"]}]